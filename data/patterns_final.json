[
  {
    "name": "Factory Method",
    "url": "https://refactoring.guru/design-patterns/factory-method",
    "problem": "Imagine that you’re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the class. After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app. Great news, right? But how about the code? At present, most of your code is coupled to the class. Adding into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again. As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app’s behavior depending on the class of transportation objects.",
    "solution": "The Factory Method pattern suggests that you replace direct object construction calls (using the operator) with calls to a special method. Don’t worry: the objects are still created via the operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method. There’s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface. For example, both and classes should implement the interface, which declares a method called . Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the class returns truck objects, whereas the factory method in the class returns ships. The code that uses the factory method (often called the code) doesn’t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract . The client knows that all transport objects are supposed to have the method, but exactly how it works isn’t important to the client.",
    "uml_image_url": "https://refactoring.guru/design-patterns/factory-method",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The creator class declares the factory method that must\n// return an object of a product class. The creator's subclasses\n// usually provide the implementation of this method.\nclass Dialog is\n    // The creator may also provide some default implementation\n    // of the factory method.\n    abstract method createButton():Button\n\n    // Note that, despite its name, the creator's primary\n    // responsibility isn't creating products. It usually\n    // contains some core business logic that relies on product\n    // objects returned by the factory method. Subclasses can\n    // indirectly change that business logic by overriding the\n    // factory method and returning a different type of product\n    // from it.\n    method render() is\n        // Call the factory method to create a product object.\n        Button okButton = createButton()\n        // Now use the product.\n        okButton.onClick(closeDialog)\n        okButton.render()\n\n\n// Concrete creators override the factory method to change the\n// resulting product's type.\nclass WindowsDialog extends Dialog is\n    method createButton():Button is\n        return new WindowsButton()\n\nclass WebDialog extends Dialog is\n    method createButton():Button is\n        return new HTMLButton()\n\n\n// The product interface declares the operations that all\n// concrete products must implement.\ninterface Button is\n    method render()\n    method onClick(f)\n\n// Concrete products provide various implementations of the\n// product interface.\nclass WindowsButton implements Button is\n    method render(a, b) is\n        // Render a button in Windows style.\n    method onClick(f) is\n        // Bind a native OS click event.\n\nclass HTMLButton implements Button is\n    method render(a, b) is\n        // Return an HTML representation of a button.\n    method onClick(f) is\n        // Bind a web browser click event.\n\n\nclass Application is\n    field dialog: Dialog\n\n    // The application picks a creator's type depending on the\n    // current configuration or environment settings.\n    method initialize() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == \"Windows\") then\n            dialog = new WindowsDialog()\n        else if (config.OS == \"Web\") then\n            dialog = new WebDialog()\n        else\n            throw new Exception(\"Error! Unknown operating system.\")\n\n    // The client code works with an instance of a concrete\n    // creator, albeit through its base interface. As long as\n    // the client keeps working with the creator via the base\n    // interface, you can pass it any creator's subclass.\n    method main() is\n        this.initialize()\n        dialog.render()"
      }
    ],
    "id": "factory-method",
    "text_for_embedding": "Pattern Name: Factory Method. Problem it solves: Imagine that you’re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the class. After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app. Great news, right? But how about the code? At present, most of your code is coupled to the class. Adding into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again. As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app’s behavior depending on the class of transportation objects. Solution: The Factory Method pattern suggests that you replace direct object construction calls (using the operator) with calls to a special method. Don’t worry: the objects are still created via the operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method. There’s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface. For example, both and classes should implement the interface, which declares a method called . Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the class returns truck objects, whereas the factory method in the class returns ships. The code that uses the factory method (often called the code) doesn’t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract . The client knows that all transport objects are supposed to have the method, but exactly how it works isn’t important to the client."
  },
  {
    "name": "Visitor",
    "url": "https://refactoring.guru/design-patterns/visitor",
    "problem": "Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city, but also more granular things like industries, sightseeing areas,etc. The nodes are connected with others if there’s a road between the real objects that they represent. Under the hood, each node type is represented by its own class, while each specific node is an object. At some point, you got a task to implement exporting the graph into XML format. At first, the job seemed pretty straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph, executing the export method. The solution was simple and elegant: thanks to polymorphism, you weren’t coupling the code which called the export method to concrete classes of nodes. Unfortunately, the system architect refused to allow you to alter existing node classes. He said that the code was already in production and he didn’t want to risk breaking it because of a potential bug in your changes. Besides, he questioned whether it makes sense to have the XML export code within the node classes. The primary job of these classes was to work with geodata. The XML export behavior would look alien there. There was another reason for the refusal. It was highly likely that after this feature was implemented, someone from the marketing department would ask you to provide the ability to export into a different format, or request some other weird stuff. This would force you to change those precious and fragile classes again.",
    "solution": "The Visitor pattern suggests that you place the new behavior into a separate class called , instead of trying to integrate it into existing classes. The original object that had to perform the behavior is now passed to one of the visitor’s methods as an argument, providing the method access to all necessary data contained within the object. Now, what if that behavior can be executed over objects of different classes? For example, in our case with XML export, the actual implementation will probably be a little bit different across various node classes. Thus, the visitor class may define not one, but a set of methods, each of which could take arguments of different types, like this: But how exactly would we call these methods, especially when dealing with the whole graph? These methods have different signatures, so we can’t use polymorphism. To pick a proper visitor method that’s able to process a given object, we’d need to check its class. Doesn’t this sound like a nightmare? You might ask, why don’t we use method overloading? That’s when you give all methods the same name, even if they support different sets of parameters. Unfortunately, even assuming that our programming language supports it at all (as Java and C# do), it won’t help us. Since the exact class of a node object is unknown in advance, the overloading mechanism won’t be able to determine the correct method to execute. It’ll default to the method that takes an object of the base class. However, the Visitor pattern addresses this problem. It uses a technique called , which helps to execute the proper method on an object without cumbersome conditionals. Instead of letting the client select a proper version of the method to call, how about we delegate this choice to objects we’re passing to the visitor as an argument? Since the objects know their own classes, they’ll be able to pick a proper method on the visitor less awkwardly. They “accept” a visitor and tell it what visiting method should be executed. I confess. We had to change the node classes after all. But at least the change is trivial and it lets us add further behaviors without altering the code once again. Now, if we extract a common interface for all visitors, all existing nodes can work with any visitor you introduce into the app. If you find yourself introducing a new behavior related to nodes, all you have to do is implement a new visitor class.",
    "uml_image_url": "https://refactoring.guru/design-patterns/visitor",
    "code_examples": [
      {
        "language": "unknown",
        "code": "class ExportVisitor implements Visitor is\n    method doForCity(City c) { ... }\n    method doForIndustry(Industry f) { ... }\n    method doForSightSeeing(SightSeeing ss) { ... }\n    // ..."
      },
      {
        "language": "unknown",
        "code": "foreach (Node node in graph)\n    if (node instanceof City)\n        exportVisitor.doForCity((City) node)\n    if (node instanceof Industry)\n        exportVisitor.doForIndustry((Industry) node)\n    // ...\n}"
      },
      {
        "language": "unknown",
        "code": "// Client code\nforeach (Node node in graph)\n    node.accept(exportVisitor)\n\n// City\nclass City is\n    method accept(Visitor v) is\n        v.doForCity(this)\n    // ...\n\n// Industry\nclass Industry is\n    method accept(Visitor v) is\n        v.doForIndustry(this)\n    // ..."
      },
      {
        "language": "unknown",
        "code": "// The element interface declares an `accept` method that takes\n// the base visitor interface as an argument.\ninterface Shape is\n    method move(x, y)\n    method draw()\n    method accept(v: Visitor)\n\n// Each concrete element class must implement the `accept`\n// method in such a way that it calls the visitor's method that\n// corresponds to the element's class.\nclass Dot implements Shape is\n    // ...\n\n    // Note that we're calling `visitDot`, which matches the\n    // current class name. This way we let the visitor know the\n    // class of the element it works with.\n    method accept(v: Visitor) is\n        v.visitDot(this)\n\nclass Circle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCircle(this)\n\nclass Rectangle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitRectangle(this)\n\nclass CompoundShape implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCompoundShape(this)\n\n\n// The Visitor interface declares a set of visiting methods that\n// correspond to element classes. The signature of a visiting\n// method lets the visitor identify the exact class of the\n// element that it's dealing with.\ninterface Visitor is\n    method visitDot(d: Dot)\n    method visitCircle(c: Circle)\n    method visitRectangle(r: Rectangle)\n    method visitCompoundShape(cs: CompoundShape)\n\n// Concrete visitors implement several versions of the same\n// algorithm, which can work with all concrete element classes.\n//\n// You can experience the biggest benefit of the Visitor pattern\n// when using it with a complex object structure such as a\n// Composite tree. In this case, it might be helpful to store\n// some intermediate state of the algorithm while executing the\n// visitor's methods over various objects of the structure.\nclass XMLExportVisitor implements Visitor is\n    method visitDot(d: Dot) is\n        // Export the dot's ID and center coordinates.\n\n    method visitCircle(c: Circle) is\n        // Export the circle's ID, center coordinates and\n        // radius.\n\n    method visitRectangle(r: Rectangle) is\n        // Export the rectangle's ID, left-top coordinates,\n        // width and height.\n\n    method visitCompoundShape(cs: CompoundShape) is\n        // Export the shape's ID as well as the list of its\n        // children's IDs.\n\n\n// The client code can run visitor operations over any set of\n// elements without figuring out their concrete classes. The\n// accept operation directs a call to the appropriate operation\n// in the visitor object.\nclass Application is\n    field allShapes: array of Shapes\n\n    method export() is\n        exportVisitor = new XMLExportVisitor()\n\n        foreach (shape in allShapes) do\n            shape.accept(exportVisitor)"
      }
    ],
    "id": "visitor",
    "text_for_embedding": "Pattern Name: Visitor. Problem it solves: Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city, but also more granular things like industries, sightseeing areas,etc. The nodes are connected with others if there’s a road between the real objects that they represent. Under the hood, each node type is represented by its own class, while each specific node is an object. At some point, you got a task to implement exporting the graph into XML format. At first, the job seemed pretty straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph, executing the export method. The solution was simple and elegant: thanks to polymorphism, you weren’t coupling the code which called the export method to concrete classes of nodes. Unfortunately, the system architect refused to allow you to alter existing node classes. He said that the code was already in production and he didn’t want to risk breaking it because of a potential bug in your changes. Besides, he questioned whether it makes sense to have the XML export code within the node classes. The primary job of these classes was to work with geodata. The XML export behavior would look alien there. There was another reason for the refusal. It was highly likely that after this feature was implemented, someone from the marketing department would ask you to provide the ability to export into a different format, or request some other weird stuff. This would force you to change those precious and fragile classes again. Solution: The Visitor pattern suggests that you place the new behavior into a separate class called , instead of trying to integrate it into existing classes. The original object that had to perform the behavior is now passed to one of the visitor’s methods as an argument, providing the method access to all necessary data contained within the object. Now, what if that behavior can be executed over objects of different classes? For example, in our case with XML export, the actual implementation will probably be a little bit different across various node classes. Thus, the visitor class may define not one, but a set of methods, each of which could take arguments of different types, like this: But how exactly would we call these methods, especially when dealing with the whole graph? These methods have different signatures, so we can’t use polymorphism. To pick a proper visitor method that’s able to process a given object, we’d need to check its class. Doesn’t this sound like a nightmare? You might ask, why don’t we use method overloading? That’s when you give all methods the same name, even if they support different sets of parameters. Unfortunately, even assuming that our programming language supports it at all (as Java and C# do), it won’t help us. Since the exact class of a node object is unknown in advance, the overloading mechanism won’t be able to determine the correct method to execute. It’ll default to the method that takes an object of the base class. However, the Visitor pattern addresses this problem. It uses a technique called , which helps to execute the proper method on an object without cumbersome conditionals. Instead of letting the client select a proper version of the method to call, how about we delegate this choice to objects we’re passing to the visitor as an argument? Since the objects know their own classes, they’ll be able to pick a proper method on the visitor less awkwardly. They “accept” a visitor and tell it what visiting method should be executed. I confess. We had to change the node classes after all. But at least the change is trivial and it lets us add further behaviors without altering the code once again. Now, if we extract a common interface for all visitors, all existing nodes can work with any visitor you introduce into the app. If you find yourself introducing a new behavior related to nodes, all you have to do is implement a new visitor class."
  },
  {
    "name": "Template Method",
    "url": "https://refactoring.guru/design-patterns/template-method",
    "problem": "Imagine that you’re creating a data mining application that analyzes corporate documents. Users feed the app documents in various formats (PDF, DOC, CSV), and it tries to extract meaningful data from these docs in a uniform format. The first version of the app could work only with DOC files. In the following version, it was able to support CSV files. A month later, you “taught” it to extract data from PDF files. At some point, you noticed that all three classes have a lot of similar code. While the code for dealing with various data formats was entirely different in all classes, the code for data processing and analysis is almost identical. Wouldn’t it be great to get rid of the code duplication, leaving the algorithm structure intact? There was another problem related to client code that used these classes. It had lots of conditionals that picked a proper course of action depending on the class of the processing object. If all three processing classes had a common interface or a base class, you’d be able to eliminate the conditionals in client code and use polymorphism when calling methods on a processing object.",
    "solution": "The Template Method pattern suggests that you break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single The steps may either be , or have some default implementation. To use the algorithm, the client is supposed to provide its own subclass, implement all abstract steps, and override some of the optional ones if needed (but not the template method itself). Let’s see how this will play out in our data mining app. We can create a base class for all three parsing algorithms. This class defines a template method consisting of a series of calls to various document-processing steps. At first, we can declare all steps , forcing the subclasses to provide their own implementations for these methods. In our case, subclasses already have all necessary implementations, so the only thing we might need to do is adjust signatures of the methods to match the methods of the superclass. Now, let’s see what we can do to get rid of the duplicate code. It looks like the code for opening/closing files and extracting/parsing data is different for various data formats, so there’s no point in touching those methods. However, implementation of other steps, such as analyzing the raw data and composing reports, is very similar, so it can be pulled up into the base class, where subclasses can share that code. As you can see, we’ve got two types of steps: There’s another type of step, called . A hook is an optional step with an empty body. A template method would work even if a hook isn’t overridden. Usually, hooks are placed before and after crucial steps of algorithms, providing subclasses with additional extension points for an algorithm.",
    "uml_image_url": "https://refactoring.guru/design-patterns/template-method",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The abstract class defines a template method that contains a\n// skeleton of some algorithm composed of calls, usually to\n// abstract primitive operations. Concrete subclasses implement\n// these operations, but leave the template method itself\n// intact.\nclass GameAI is\n    // The template method defines the skeleton of an algorithm.\n    method turn() is\n        collectResources()\n        buildStructures()\n        buildUnits()\n        attack()\n\n    // Some of the steps may be implemented right in a base\n    // class.\n    method collectResources() is\n        foreach (s in this.builtStructures) do\n            s.collect()\n\n    // And some of them may be defined as abstract.\n    abstract method buildStructures()\n    abstract method buildUnits()\n\n    // A class can have several template methods.\n    method attack() is\n        enemy = closestEnemy()\n        if (enemy == null)\n            sendScouts(map.center)\n        else\n            sendWarriors(enemy.position)\n\n    abstract method sendScouts(position)\n    abstract method sendWarriors(position)\n\n// Concrete classes have to implement all abstract operations of\n// the base class but they must not override the template method\n// itself.\nclass OrcsAI extends GameAI is\n    method buildStructures() is\n        if (there are some resources) then\n            // Build farms, then barracks, then stronghold.\n\n    method buildUnits() is\n        if (there are plenty of resources) then\n            if (there are no scouts)\n                // Build peon, add it to scouts group.\n            else\n                // Build grunt, add it to warriors group.\n\n    // ...\n\n    method sendScouts(position) is\n        if (scouts.length > 0) then\n            // Send scouts to position.\n\n    method sendWarriors(position) is\n        if (warriors.length > 5) then\n            // Send warriors to position.\n\n// Subclasses can also override some operations with a default\n// implementation.\nclass MonstersAI extends GameAI is\n    method collectResources() is\n        // Monsters don't collect resources.\n\n    method buildStructures() is\n        // Monsters don't build structures.\n\n    method buildUnits() is\n        // Monsters don't build units."
      }
    ],
    "id": "template-method",
    "text_for_embedding": "Pattern Name: Template Method. Problem it solves: Imagine that you’re creating a data mining application that analyzes corporate documents. Users feed the app documents in various formats (PDF, DOC, CSV), and it tries to extract meaningful data from these docs in a uniform format. The first version of the app could work only with DOC files. In the following version, it was able to support CSV files. A month later, you “taught” it to extract data from PDF files. At some point, you noticed that all three classes have a lot of similar code. While the code for dealing with various data formats was entirely different in all classes, the code for data processing and analysis is almost identical. Wouldn’t it be great to get rid of the code duplication, leaving the algorithm structure intact? There was another problem related to client code that used these classes. It had lots of conditionals that picked a proper course of action depending on the class of the processing object. If all three processing classes had a common interface or a base class, you’d be able to eliminate the conditionals in client code and use polymorphism when calling methods on a processing object. Solution: The Template Method pattern suggests that you break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single The steps may either be , or have some default implementation. To use the algorithm, the client is supposed to provide its own subclass, implement all abstract steps, and override some of the optional ones if needed (but not the template method itself). Let’s see how this will play out in our data mining app. We can create a base class for all three parsing algorithms. This class defines a template method consisting of a series of calls to various document-processing steps. At first, we can declare all steps , forcing the subclasses to provide their own implementations for these methods. In our case, subclasses already have all necessary implementations, so the only thing we might need to do is adjust signatures of the methods to match the methods of the superclass. Now, let’s see what we can do to get rid of the duplicate code. It looks like the code for opening/closing files and extracting/parsing data is different for various data formats, so there’s no point in touching those methods. However, implementation of other steps, such as analyzing the raw data and composing reports, is very similar, so it can be pulled up into the base class, where subclasses can share that code. As you can see, we’ve got two types of steps: There’s another type of step, called . A hook is an optional step with an empty body. A template method would work even if a hook isn’t overridden. Usually, hooks are placed before and after crucial steps of algorithms, providing subclasses with additional extension points for an algorithm."
  },
  {
    "name": "Strategy",
    "url": "https://refactoring.guru/design-patterns/strategy",
    "problem": "One day you decided to create a navigation app for casual travelers. The app was centered around a beautiful map which helped users quickly orient themselves in any city. One of the most requested features for the app was automatic route planning. A user should be able to enter an address and see the fastest route to that destination displayed on the map. The first version of the app could only build the routes over roads. People who traveled by car were bursting with joy. But apparently, not everybody likes to drive on their vacation. So with the next update, you added an option to build walking routes. Right after that, you added another option to let people use public transport in their routes. However, that was only the beginning. Later you planned to add route building for cyclists. And even later, another option for building routes through all of a city’s tourist attractions. While from a business perspective the app was a success, the technical part caused you many headaches. Each time you added a new routing algorithm, the main class of the navigator doubled in size. At some point, the beast became too hard to maintain. Any change to one of the algorithms, whether it was a simple bug fix or a slight adjustment of the street score, affected the whole class, increasing the chance of creating an error in already-working code. In addition, teamwork became inefficient. Your teammates, who had been hired right after the successful release, complain that they spend too much time resolving merge conflicts. Implementing a new feature requires you to change the same huge class, conflicting with the code produced by other people.",
    "solution": "The Strategy pattern suggests that you take a class that does something specific in a lot of different ways and extract all of these algorithms into separate classes called . The original class, called , must have a field for storing a reference to one of the strategies. The context delegates the work to a linked strategy object instead of executing it on its own. The context isn’t responsible for selecting an appropriate algorithm for the job. Instead, the client passes the desired strategy to the context. In fact, the context doesn’t know much about strategies. It works with all strategies through the same generic interface, which only exposes a single method for triggering the algorithm encapsulated within the selected strategy. This way the context becomes independent of concrete strategies, so you can add new algorithms or modify existing ones without changing the code of the context or other strategies. In our navigation app, each routing algorithm can be extracted to its own class with a single method. The method accepts an origin and destination and returns a collection of the route’s checkpoints. Even though given the same arguments, each routing class might build a different route, the main navigator class doesn’t really care which algorithm is selected since its primary job is to render a set of checkpoints on the map. The class has a method for switching the active routing strategy, so its clients, such as the buttons in the user interface, can replace the currently selected routing behavior with another one.",
    "uml_image_url": "https://refactoring.guru/design-patterns/strategy",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The strategy interface declares operations common to all\n// supported versions of some algorithm. The context uses this\n// interface to call the algorithm defined by the concrete\n// strategies.\ninterface Strategy is\n    method execute(a, b)\n\n// Concrete strategies implement the algorithm while following\n// the base strategy interface. The interface makes them\n// interchangeable in the context.\nclass ConcreteStrategyAdd implements Strategy is\n    method execute(a, b) is\n        return a + b\n\nclass ConcreteStrategySubtract implements Strategy is\n    method execute(a, b) is\n        return a - b\n\nclass ConcreteStrategyMultiply implements Strategy is\n    method execute(a, b) is\n        return a * b\n\n// The context defines the interface of interest to clients.\nclass Context is\n    // The context maintains a reference to one of the strategy\n    // objects. The context doesn't know the concrete class of a\n    // strategy. It should work with all strategies via the\n    // strategy interface.\n    private strategy: Strategy\n\n    // Usually the context accepts a strategy through the\n    // constructor, and also provides a setter so that the\n    // strategy can be switched at runtime.\n    method setStrategy(Strategy strategy) is\n        this.strategy = strategy\n\n    // The context delegates some work to the strategy object\n    // instead of implementing multiple versions of the\n    // algorithm on its own.\n    method executeStrategy(int a, int b) is\n        return strategy.execute(a, b)\n\n\n// The client code picks a concrete strategy and passes it to\n// the context. The client should be aware of the differences\n// between strategies in order to make the right choice.\nclass ExampleApplication is\n    method main() is\n        Create context object.\n\n        Read first number.\n        Read last number.\n        Read the desired action from user input.\n\n        if (action == addition) then\n            context.setStrategy(new ConcreteStrategyAdd())\n\n        if (action == subtraction) then\n            context.setStrategy(new ConcreteStrategySubtract())\n\n        if (action == multiplication) then\n            context.setStrategy(new ConcreteStrategyMultiply())\n\n        result = context.executeStrategy(First number, Second number)\n\n        Print result."
      }
    ],
    "id": "strategy",
    "text_for_embedding": "Pattern Name: Strategy. Problem it solves: One day you decided to create a navigation app for casual travelers. The app was centered around a beautiful map which helped users quickly orient themselves in any city. One of the most requested features for the app was automatic route planning. A user should be able to enter an address and see the fastest route to that destination displayed on the map. The first version of the app could only build the routes over roads. People who traveled by car were bursting with joy. But apparently, not everybody likes to drive on their vacation. So with the next update, you added an option to build walking routes. Right after that, you added another option to let people use public transport in their routes. However, that was only the beginning. Later you planned to add route building for cyclists. And even later, another option for building routes through all of a city’s tourist attractions. While from a business perspective the app was a success, the technical part caused you many headaches. Each time you added a new routing algorithm, the main class of the navigator doubled in size. At some point, the beast became too hard to maintain. Any change to one of the algorithms, whether it was a simple bug fix or a slight adjustment of the street score, affected the whole class, increasing the chance of creating an error in already-working code. In addition, teamwork became inefficient. Your teammates, who had been hired right after the successful release, complain that they spend too much time resolving merge conflicts. Implementing a new feature requires you to change the same huge class, conflicting with the code produced by other people. Solution: The Strategy pattern suggests that you take a class that does something specific in a lot of different ways and extract all of these algorithms into separate classes called . The original class, called , must have a field for storing a reference to one of the strategies. The context delegates the work to a linked strategy object instead of executing it on its own. The context isn’t responsible for selecting an appropriate algorithm for the job. Instead, the client passes the desired strategy to the context. In fact, the context doesn’t know much about strategies. It works with all strategies through the same generic interface, which only exposes a single method for triggering the algorithm encapsulated within the selected strategy. This way the context becomes independent of concrete strategies, so you can add new algorithms or modify existing ones without changing the code of the context or other strategies. In our navigation app, each routing algorithm can be extracted to its own class with a single method. The method accepts an origin and destination and returns a collection of the route’s checkpoints. Even though given the same arguments, each routing class might build a different route, the main navigator class doesn’t really care which algorithm is selected since its primary job is to render a set of checkpoints on the map. The class has a method for switching the active routing strategy, so its clients, such as the buttons in the user interface, can replace the currently selected routing behavior with another one."
  },
  {
    "name": "State",
    "url": "https://refactoring.guru/design-patterns/state",
    "problem": "The State pattern is closely related to the concept of a . The main idea is that, at any given moment, there’s a number of which a program can be in. Within any unique state, the program behaves differently, and the program can be switched from one state to another instantaneously. However, depending on a current state, the program may or may not switch to certain other states. These switching rules, called , are also finite and predetermined. You can also apply this approach to objects. Imagine that we have a class. A document can be in one of three states: , and . The method of the document works a little bit differently in each state: State machines are usually implemented with lots of conditional statements ( or ) that select the appropriate behavior depending on the current state of the object. Usually, this “state” is just a set of values of the object’s fields. Even if you’ve never heard about finite-state machines before, you’ve probably implemented a state at least once. Does the following code structure ring a bell? The biggest weakness of a state machine based on conditionals reveals itself once we start adding more and more states and state-dependent behaviors to the class. Most methods will contain monstrous conditionals that pick the proper behavior of a method according to the current state. Code like this is very difficult to maintain because any change to the transition logic may require changing state conditionals in every method. The problem tends to get bigger as a project evolves. It’s quite difficult to predict all possible states and transitions at the design stage. Hence, a lean state machine built with a limited set of conditionals can grow into a bloated mess over time.",
    "solution": "The State pattern suggests that you create new classes for all possible states of an object and extract all state-specific behaviors into these classes. Instead of implementing all behaviors on its own, the original object, called , stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object. To transition the context into another state, replace the active state object with another object that represents that new state. This is possible only if all state classes follow the same interface and the context itself works with these objects through that interface. This structure may look similar to the pattern, but there’s one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other.",
    "uml_image_url": "https://refactoring.guru/design-patterns/state",
    "code_examples": [
      {
        "language": "unknown",
        "code": "class Document is\n    field state: string\n    // ...\n    method publish() is\n        switch (state)\n            \"draft\":\n                state = \"moderation\"\n                break\n            \"moderation\":\n                if (currentUser.role == \"admin\")\n                    state = \"published\"\n                break\n            \"published\":\n                // Do nothing.\n                break\n    // ..."
      },
      {
        "language": "unknown",
        "code": "// The AudioPlayer class acts as a context. It also maintains a\n// reference to an instance of one of the state classes that\n// represents the current state of the audio player.\nclass AudioPlayer is\n    field state: State\n    field UI, volume, playlist, currentSong\n\n    constructor AudioPlayer() is\n        this.state = new ReadyState(this)\n\n        // Context delegates handling user input to a state\n        // object. Naturally, the outcome depends on what state\n        // is currently active, since each state can handle the\n        // input differently.\n        UI = new UserInterface()\n        UI.lockButton.onClick(this.clickLock)\n        UI.playButton.onClick(this.clickPlay)\n        UI.nextButton.onClick(this.clickNext)\n        UI.prevButton.onClick(this.clickPrevious)\n\n    // Other objects must be able to switch the audio player's\n    // active state.\n    method changeState(state: State) is\n        this.state = state\n\n    // UI methods delegate execution to the active state.\n    method clickLock() is\n        state.clickLock()\n    method clickPlay() is\n        state.clickPlay()\n    method clickNext() is\n        state.clickNext()\n    method clickPrevious() is\n        state.clickPrevious()\n\n    // A state may call some service methods on the context.\n    method startPlayback() is\n        // ...\n    method stopPlayback() is\n        // ...\n    method nextSong() is\n        // ...\n    method previousSong() is\n        // ...\n    method fastForward(time) is\n        // ...\n    method rewind(time) is\n        // ...\n\n\n// The base state class declares methods that all concrete\n// states should implement and also provides a backreference to\n// the context object associated with the state. States can use\n// the backreference to transition the context to another state.\nabstract class State is\n    protected field player: AudioPlayer\n\n    // Context passes itself through the state constructor. This\n    // may help a state fetch some useful context data if it's\n    // needed.\n    constructor State(player) is\n        this.player = player\n\n    abstract method clickLock()\n    abstract method clickPlay()\n    abstract method clickNext()\n    abstract method clickPrevious()\n\n\n// Concrete states implement various behaviors associated with a\n// state of the context.\nclass LockedState extends State is\n\n    // When you unlock a locked player, it may assume one of two\n    // states.\n    method clickLock() is\n        if (player.playing)\n            player.changeState(new PlayingState(player))\n        else\n            player.changeState(new ReadyState(player))\n\n    method clickPlay() is\n        // Locked, so do nothing.\n\n    method clickNext() is\n        // Locked, so do nothing.\n\n    method clickPrevious() is\n        // Locked, so do nothing.\n\n\n// They can also trigger state transitions in the context.\nclass ReadyState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.startPlayback()\n        player.changeState(new PlayingState(player))\n\n    method clickNext() is\n        player.nextSong()\n\n    method clickPrevious() is\n        player.previousSong()\n\n\nclass PlayingState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.stopPlayback()\n        player.changeState(new ReadyState(player))\n\n    method clickNext() is\n        if (event.doubleclick)\n            player.nextSong()\n        else\n            player.fastForward(5)\n\n    method clickPrevious() is\n        if (event.doubleclick)\n            player.previous()\n        else\n            player.rewind(5)"
      }
    ],
    "id": "state",
    "text_for_embedding": "Pattern Name: State. Problem it solves: The State pattern is closely related to the concept of a . The main idea is that, at any given moment, there’s a number of which a program can be in. Within any unique state, the program behaves differently, and the program can be switched from one state to another instantaneously. However, depending on a current state, the program may or may not switch to certain other states. These switching rules, called , are also finite and predetermined. You can also apply this approach to objects. Imagine that we have a class. A document can be in one of three states: , and . The method of the document works a little bit differently in each state: State machines are usually implemented with lots of conditional statements ( or ) that select the appropriate behavior depending on the current state of the object. Usually, this “state” is just a set of values of the object’s fields. Even if you’ve never heard about finite-state machines before, you’ve probably implemented a state at least once. Does the following code structure ring a bell? The biggest weakness of a state machine based on conditionals reveals itself once we start adding more and more states and state-dependent behaviors to the class. Most methods will contain monstrous conditionals that pick the proper behavior of a method according to the current state. Code like this is very difficult to maintain because any change to the transition logic may require changing state conditionals in every method. The problem tends to get bigger as a project evolves. It’s quite difficult to predict all possible states and transitions at the design stage. Hence, a lean state machine built with a limited set of conditionals can grow into a bloated mess over time. Solution: The State pattern suggests that you create new classes for all possible states of an object and extract all state-specific behaviors into these classes. Instead of implementing all behaviors on its own, the original object, called , stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object. To transition the context into another state, replace the active state object with another object that represents that new state. This is possible only if all state classes follow the same interface and the context itself works with these objects through that interface. This structure may look similar to the pattern, but there’s one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other."
  },
  {
    "name": "Observer",
    "url": "https://refactoring.guru/design-patterns/observer",
    "problem": "Imagine that you have two types of objects: a and a . The customer is very interested in a particular brand of product (say, it’s a new model of the iPhone) which should become available in the store very soon. The customer could visit the store every day and check product availability. But while the product is still en route, most of these trips would be pointless. On the other hand, the store could send tons of emails (which might be considered spam) to all customers each time a new product becomes available. This would save some customers from endless trips to the store. At the same time, it’d upset other customers who aren’t interested in new products. It looks like we’ve got a conflict. Either the customer wastes time checking product availability or the store wastes resources notifying the wrong customers.",
    "solution": "The object that has some interesting state is often called , but since it’s also going to notify other objects about the changes to its state, we’ll call it . All other objects that want to track changes to the publisher’s state are called . The Observer pattern suggests that you add a subscription mechanism to the publisher class so individual objects can subscribe to or unsubscribe from a stream of events coming from that publisher. Fear not! Everything isn’t as complicated as it sounds. In reality, this mechanism consists of 1) an array field for storing a list of references to subscriber objects and 2) several public methods which allow adding subscribers to and removing them from that list. Now, whenever an important event happens to the publisher, it goes over its subscribers and calls the specific notification method on their objects. Real apps might have dozens of different subscriber classes that are interested in tracking events of the same publisher class. You wouldn’t want to couple the publisher to all of those classes. Besides, you might not even know about some of them beforehand if your publisher class is supposed to be used by other people. That’s why it’s crucial that all subscribers implement the same interface and that the publisher communicates with them only via that interface. This interface should declare the notification method along with a set of parameters that the publisher can use to pass some contextual data along with the notification. If your app has several different types of publishers and you want to make your subscribers compatible with all of them, you can go even further and make all publishers follow the same interface. This interface would only need to describe a few subscription methods. The interface would allow subscribers to observe publishers’ states without coupling to their concrete classes.",
    "uml_image_url": "https://refactoring.guru/design-patterns/observer",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The base publisher class includes subscription management\n// code and notification methods.\nclass EventManager is\n    private field listeners: hash map of event types and listeners\n\n    method subscribe(eventType, listener) is\n        listeners.add(eventType, listener)\n\n    method unsubscribe(eventType, listener) is\n        listeners.remove(eventType, listener)\n\n    method notify(eventType, data) is\n        foreach (listener in listeners.of(eventType)) do\n            listener.update(data)\n\n// The concrete publisher contains real business logic that's\n// interesting for some subscribers. We could derive this class\n// from the base publisher, but that isn't always possible in\n// real life because the concrete publisher might already be a\n// subclass. In this case, you can patch the subscription logic\n// in with composition, as we did here.\nclass Editor is\n    public field events: EventManager\n    private field file: File\n\n    constructor Editor() is\n        events = new EventManager()\n\n    // Methods of business logic can notify subscribers about\n    // changes.\n    method openFile(path) is\n        this.file = new File(path)\n        events.notify(\"open\", file.name)\n\n    method saveFile() is\n        file.write()\n        events.notify(\"save\", file.name)\n\n    // ...\n\n\n// Here's the subscriber interface. If your programming language\n// supports functional types, you can replace the whole\n// subscriber hierarchy with a set of functions.\ninterface EventListener is\n    method update(filename)\n\n// Concrete subscribers react to updates issued by the publisher\n// they are attached to.\nclass LoggingListener implements EventListener is\n    private field log: File\n    private field message: string\n\n    constructor LoggingListener(log_filename, message) is\n        this.log = new File(log_filename)\n        this.message = message\n\n    method update(filename) is\n        log.write(replace('%s',filename,message))\n\nclass EmailAlertsListener implements EventListener is\n    private field email: string\n    private field message: string\n\n    constructor EmailAlertsListener(email, message) is\n        this.email = email\n        this.message = message\n\n    method update(filename) is\n        system.email(email, replace('%s',filename,message))\n\n\n// An application can configure publishers and subscribers at\n// runtime.\nclass Application is\n    method config() is\n        editor = new Editor()\n\n        logger = new LoggingListener(\n            \"/path/to/log.txt\",\n            \"Someone has opened the file: %s\")\n        editor.events.subscribe(\"open\", logger)\n\n        emailAlerts = new EmailAlertsListener(\n            \"admin@example.com\",\n            \"Someone has changed the file: %s\")\n        editor.events.subscribe(\"save\", emailAlerts)"
      }
    ],
    "id": "observer",
    "text_for_embedding": "Pattern Name: Observer. Problem it solves: Imagine that you have two types of objects: a and a . The customer is very interested in a particular brand of product (say, it’s a new model of the iPhone) which should become available in the store very soon. The customer could visit the store every day and check product availability. But while the product is still en route, most of these trips would be pointless. On the other hand, the store could send tons of emails (which might be considered spam) to all customers each time a new product becomes available. This would save some customers from endless trips to the store. At the same time, it’d upset other customers who aren’t interested in new products. It looks like we’ve got a conflict. Either the customer wastes time checking product availability or the store wastes resources notifying the wrong customers. Solution: The object that has some interesting state is often called , but since it’s also going to notify other objects about the changes to its state, we’ll call it . All other objects that want to track changes to the publisher’s state are called . The Observer pattern suggests that you add a subscription mechanism to the publisher class so individual objects can subscribe to or unsubscribe from a stream of events coming from that publisher. Fear not! Everything isn’t as complicated as it sounds. In reality, this mechanism consists of 1) an array field for storing a list of references to subscriber objects and 2) several public methods which allow adding subscribers to and removing them from that list. Now, whenever an important event happens to the publisher, it goes over its subscribers and calls the specific notification method on their objects. Real apps might have dozens of different subscriber classes that are interested in tracking events of the same publisher class. You wouldn’t want to couple the publisher to all of those classes. Besides, you might not even know about some of them beforehand if your publisher class is supposed to be used by other people. That’s why it’s crucial that all subscribers implement the same interface and that the publisher communicates with them only via that interface. This interface should declare the notification method along with a set of parameters that the publisher can use to pass some contextual data along with the notification. If your app has several different types of publishers and you want to make your subscribers compatible with all of them, you can go even further and make all publishers follow the same interface. This interface would only need to describe a few subscription methods. The interface would allow subscribers to observe publishers’ states without coupling to their concrete classes."
  },
  {
    "name": "Memento",
    "url": "https://refactoring.guru/design-patterns/memento",
    "problem": "Imagine that you’re creating a text editor app. In addition to simple text editing, your editor can format text, insert inline images,etc. At some point, you decided to let users undo any operations carried out on the text. This feature has become so common over the years that nowadays people expect every app to have it. For the implementation, you chose to take the direct approach. Before performing any operation, the app records the state of all objects and saves it in some storage. Later, when a user decides to revert an action, the app fetches the latest snapshot from the history and uses it to restore the state of all objects. Let’s think about those state snapshots. How exactly would you produce one? You’d probably need to go over all the fields in an object and copy their values into storage. However, this would only work if the object had quite relaxed access restrictions to its contents. Unfortunately, most real objects won’t let others peek inside them that easily, hiding all significant data in private fields. Ignore that problem for now and let’s assume that our objects behave like hippies: preferring open relations and keeping their state public. While this approach would solve the immediate problem and let you produce snapshots of objects’ states at will, it still has some serious issues. In the future, you might decide to refactor some of the editor classes, or add or remove some of the fields. Sounds easy, but this would also require changing the classes responsible for copying the state of the affected objects. But there’s more. Let’s consider the actual “snapshots” of the editor’s state. What data does it contain? At a bare minimum, it must contain the actual text, cursor coordinates, current scroll position,etc. To make a snapshot, you’d need to collect these values and put them into some kind of container. Most likely, you’re going to store lots of these container objects inside some list that would represent the history. Therefore the containers would probably end up being objects of one class. The class would have almost no methods, but lots of fields that mirror the editor’s state. To allow other objects to write and read data to and from a snapshot, you’d probably need to make its fields public. That would expose all the editor’s states, private or not. Other classes would become dependent on every little change to the snapshot class, which would otherwise happen within private fields and methods without affecting outer classes. It looks like we’ve reached a dead end: you either expose all internal details of classes, making them too fragile, or restrict access to their state, making it impossible to produce snapshots. Is there any other way to implement the \"undo\"?",
    "solution": "All problems that we’ve just experienced are caused by broken encapsulation. Some objects try to do more than they are supposed to. To collect the data required to perform some action, they invade the private space of other objects instead of letting these objects perform the actual action. The Memento pattern delegates creating the state snapshots to the actual owner of that state, the object. Hence, instead of other objects trying to copy the editor’s state from the “outside,” the editor class itself can make the snapshot since it has full access to its own state. The pattern suggests storing the copy of the object’s state in a special object called . The contents of the memento aren’t accessible to any other object except the one that produced it. Other objects must communicate with mementos using a limited interface which may allow fetching the snapshot’s metadata (creation time, the name of the performed operation,etc.), but not the original object’s state contained in the snapshot. Such a restrictive policy lets you store mementos inside other objects, usually called . Since the caretaker works with the memento only via the limited interface, it’s not able to tamper with the state stored inside the memento. At the same time, the originator has access to all fields inside the memento, allowing it to restore its previous state at will. In our text editor example, we can create a separate history class to act as the caretaker. A stack of mementos stored inside the caretaker will grow each time the editor is about to execute an operation. You could even render this stack within the app’s UI, displaying the history of previously performed operations to a user. When a user triggers the undo, the history grabs the most recent memento from the stack and passes it back to the editor, requesting a roll-back. Since the editor has full access to the memento, it changes its own state with the values taken from the memento.",
    "uml_image_url": "https://refactoring.guru/design-patterns/memento",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The originator holds some important data that may change over\n// time. It also defines a method for saving its state inside a\n// memento and another method for restoring the state from it.\nclass Editor is\n    private field text, curX, curY, selectionWidth\n\n    method setText(text) is\n        this.text = text\n\n    method setCursor(x, y) is\n        this.curX = x\n        this.curY = y\n\n    method setSelectionWidth(width) is\n        this.selectionWidth = width\n\n    // Saves the current state inside a memento.\n    method createSnapshot():Snapshot is\n        // Memento is an immutable object; that's why the\n        // originator passes its state to the memento's\n        // constructor parameters.\n        return new Snapshot(this, text, curX, curY, selectionWidth)\n\n// The memento class stores the past state of the editor.\nclass Snapshot is\n    private field editor: Editor\n    private field text, curX, curY, selectionWidth\n\n    constructor Snapshot(editor, text, curX, curY, selectionWidth) is\n        this.editor = editor\n        this.text = text\n        this.curX = x\n        this.curY = y\n        this.selectionWidth = selectionWidth\n\n    // At some point, a previous state of the editor can be\n    // restored using a memento object.\n    method restore() is\n        editor.setText(text)\n        editor.setCursor(curX, curY)\n        editor.setSelectionWidth(selectionWidth)\n\n// A command object can act as a caretaker. In that case, the\n// command gets a memento just before it changes the\n// originator's state. When undo is requested, it restores the\n// originator's state from a memento.\nclass Command is\n    private field backup: Snapshot\n\n    method makeBackup() is\n        backup = editor.createSnapshot()\n\n    method undo() is\n        if (backup != null)\n            backup.restore()\n    // ..."
      }
    ],
    "id": "memento",
    "text_for_embedding": "Pattern Name: Memento. Problem it solves: Imagine that you’re creating a text editor app. In addition to simple text editing, your editor can format text, insert inline images,etc. At some point, you decided to let users undo any operations carried out on the text. This feature has become so common over the years that nowadays people expect every app to have it. For the implementation, you chose to take the direct approach. Before performing any operation, the app records the state of all objects and saves it in some storage. Later, when a user decides to revert an action, the app fetches the latest snapshot from the history and uses it to restore the state of all objects. Let’s think about those state snapshots. How exactly would you produce one? You’d probably need to go over all the fields in an object and copy their values into storage. However, this would only work if the object had quite relaxed access restrictions to its contents. Unfortunately, most real objects won’t let others peek inside them that easily, hiding all significant data in private fields. Ignore that problem for now and let’s assume that our objects behave like hippies: preferring open relations and keeping their state public. While this approach would solve the immediate problem and let you produce snapshots of objects’ states at will, it still has some serious issues. In the future, you might decide to refactor some of the editor classes, or add or remove some of the fields. Sounds easy, but this would also require changing the classes responsible for copying the state of the affected objects. But there’s more. Let’s consider the actual “snapshots” of the editor’s state. What data does it contain? At a bare minimum, it must contain the actual text, cursor coordinates, current scroll position,etc. To make a snapshot, you’d need to collect these values and put them into some kind of container. Most likely, you’re going to store lots of these container objects inside some list that would represent the history. Therefore the containers would probably end up being objects of one class. The class would have almost no methods, but lots of fields that mirror the editor’s state. To allow other objects to write and read data to and from a snapshot, you’d probably need to make its fields public. That would expose all the editor’s states, private or not. Other classes would become dependent on every little change to the snapshot class, which would otherwise happen within private fields and methods without affecting outer classes. It looks like we’ve reached a dead end: you either expose all internal details of classes, making them too fragile, or restrict access to their state, making it impossible to produce snapshots. Is there any other way to implement the \"undo\"? Solution: All problems that we’ve just experienced are caused by broken encapsulation. Some objects try to do more than they are supposed to. To collect the data required to perform some action, they invade the private space of other objects instead of letting these objects perform the actual action. The Memento pattern delegates creating the state snapshots to the actual owner of that state, the object. Hence, instead of other objects trying to copy the editor’s state from the “outside,” the editor class itself can make the snapshot since it has full access to its own state. The pattern suggests storing the copy of the object’s state in a special object called . The contents of the memento aren’t accessible to any other object except the one that produced it. Other objects must communicate with mementos using a limited interface which may allow fetching the snapshot’s metadata (creation time, the name of the performed operation,etc.), but not the original object’s state contained in the snapshot. Such a restrictive policy lets you store mementos inside other objects, usually called . Since the caretaker works with the memento only via the limited interface, it’s not able to tamper with the state stored inside the memento. At the same time, the originator has access to all fields inside the memento, allowing it to restore its previous state at will. In our text editor example, we can create a separate history class to act as the caretaker. A stack of mementos stored inside the caretaker will grow each time the editor is about to execute an operation. You could even render this stack within the app’s UI, displaying the history of previously performed operations to a user. When a user triggers the undo, the history grabs the most recent memento from the stack and passes it back to the editor, requesting a roll-back. Since the editor has full access to the memento, it changes its own state with the values taken from the memento."
  },
  {
    "name": "Mediator",
    "url": "https://refactoring.guru/design-patterns/mediator",
    "problem": "Say you have a dialog for creating and editing customer profiles. It consists of various form controls such as text fields, checkboxes, buttons,etc. Some of the form elements may interact with others. For instance, selecting the “I have a dog” checkbox may reveal a hidden text field for entering the dog’s name. Another example is the submit button that has to validate values of all fields before saving the data. By having this logic implemented directly inside the code of the form elements you make these elements’ classes much harder to reuse in other forms of the app. For example, you won’t be able to use that checkbox class inside another form, because it’s coupled to the dog’s text field. You can use either all the classes involved in rendering the profile form, or none at all.",
    "solution": "The Mediator pattern suggests that you should cease all direct communication between the components which you want to make independent of each other. Instead, these components must collaborate indirectly, by calling a special mediator object that redirects the calls to appropriate components. As a result, the components depend only on a single mediator class instead of being coupled to dozens of their colleagues. In our example with the profile editing form, the dialog class itself may act as the mediator. Most likely, the dialog class is already aware of all of its sub-elements, so you won’t even need to introduce new dependencies into this class. The most significant change happens to the actual form elements. Let’s consider the submit button. Previously, each time a user clicked the button, it had to validate the values of all individual form elements. Now its single job is to notify the dialog about the click. Upon receiving this notification, the dialog itself performs the validations or passes the task to the individual elements. Thus, instead of being tied to a dozen form elements, the button is only dependent on the dialog class. You can go further and make the dependency even looser by extracting the common interface for all types of dialogs. The interface would declare the notification method which all form elements can use to notify the dialog about events happening to those elements. Thus, our submit button should now be able to work with any dialog that implements that interface. This way, the Mediator pattern lets you encapsulate a complex web of relations between various objects inside a single mediator object. The fewer dependencies a class has, the easier it becomes to modify, extend or reuse that class.",
    "uml_image_url": "https://refactoring.guru/design-patterns/mediator",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The mediator interface declares a method used by components\n// to notify the mediator about various events. The mediator may\n// react to these events and pass the execution to other\n// components.\ninterface Mediator is\n    method notify(sender: Component, event: string)\n\n\n// The concrete mediator class. The intertwined web of\n// connections between individual components has been untangled\n// and moved into the mediator.\nclass AuthenticationDialog implements Mediator is\n    private field title: string\n    private field loginOrRegisterChkBx: Checkbox\n    private field loginUsername, loginPassword: Textbox\n    private field registrationUsername, registrationPassword,\n                  registrationEmail: Textbox\n    private field okBtn, cancelBtn: Button\n\n    constructor AuthenticationDialog() is\n        // Create all component objects by passing the current\n        // mediator into their constructors to establish links.\n\n    // When something happens with a component, it notifies the\n    // mediator. Upon receiving a notification, the mediator may\n    // do something on its own or pass the request to another\n    // component.\n    method notify(sender, event) is\n        if (sender == loginOrRegisterChkBx and event == \"check\")\n            if (loginOrRegisterChkBx.checked)\n                title = \"Log in\"\n                // 1. Show login form components.\n                // 2. Hide registration form components.\n            else\n                title = \"Register\"\n                // 1. Show registration form components.\n                // 2. Hide login form components\n\n        if (sender == okBtn && event == \"click\")\n            if (loginOrRegister.checked)\n                // Try to find a user using login credentials.\n                if (!found)\n                    // Show an error message above the login\n                    // field.\n            else\n                // 1. Create a user account using data from the\n                // registration fields.\n                // 2. Log that user in.\n                // ...\n\n\n// Components communicate with a mediator using the mediator\n// interface. Thanks to that, you can use the same components in\n// other contexts by linking them with different mediator\n// objects.\nclass Component is\n    field dialog: Mediator\n\n    constructor Component(dialog) is\n        this.dialog = dialog\n\n    method click() is\n        dialog.notify(this, \"click\")\n\n    method keypress() is\n        dialog.notify(this, \"keypress\")\n\n// Concrete components don't talk to each other. They have only\n// one communication channel, which is sending notifications to\n// the mediator.\nclass Button extends Component is\n    // ...\n\nclass Textbox extends Component is\n    // ...\n\nclass Checkbox extends Component is\n    method check() is\n        dialog.notify(this, \"check\")\n    // ..."
      }
    ],
    "id": "mediator",
    "text_for_embedding": "Pattern Name: Mediator. Problem it solves: Say you have a dialog for creating and editing customer profiles. It consists of various form controls such as text fields, checkboxes, buttons,etc. Some of the form elements may interact with others. For instance, selecting the “I have a dog” checkbox may reveal a hidden text field for entering the dog’s name. Another example is the submit button that has to validate values of all fields before saving the data. By having this logic implemented directly inside the code of the form elements you make these elements’ classes much harder to reuse in other forms of the app. For example, you won’t be able to use that checkbox class inside another form, because it’s coupled to the dog’s text field. You can use either all the classes involved in rendering the profile form, or none at all. Solution: The Mediator pattern suggests that you should cease all direct communication between the components which you want to make independent of each other. Instead, these components must collaborate indirectly, by calling a special mediator object that redirects the calls to appropriate components. As a result, the components depend only on a single mediator class instead of being coupled to dozens of their colleagues. In our example with the profile editing form, the dialog class itself may act as the mediator. Most likely, the dialog class is already aware of all of its sub-elements, so you won’t even need to introduce new dependencies into this class. The most significant change happens to the actual form elements. Let’s consider the submit button. Previously, each time a user clicked the button, it had to validate the values of all individual form elements. Now its single job is to notify the dialog about the click. Upon receiving this notification, the dialog itself performs the validations or passes the task to the individual elements. Thus, instead of being tied to a dozen form elements, the button is only dependent on the dialog class. You can go further and make the dependency even looser by extracting the common interface for all types of dialogs. The interface would declare the notification method which all form elements can use to notify the dialog about events happening to those elements. Thus, our submit button should now be able to work with any dialog that implements that interface. This way, the Mediator pattern lets you encapsulate a complex web of relations between various objects inside a single mediator object. The fewer dependencies a class has, the easier it becomes to modify, extend or reuse that class."
  },
  {
    "name": "Iterator",
    "url": "https://refactoring.guru/design-patterns/iterator",
    "problem": "Collections are one of the most used data types in programming. Nonetheless, a collection is just a container for a group of objects. Most collections store their elements in simple lists. However, some of them are based on stacks, trees, graphs and other complex data structures. But no matter how a collection is structured, it must provide some way of accessing its elements so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over. This may sound like an easy job if you have a collection based on a list. You just loop over all of the elements. But how do you sequentially traverse elements of a complex data structure, such as a tree? For example, one day you might be just fine with depth-first traversal of a tree. Yet the next day you might require breadth-first traversal. And the next week, you might need something else, like random access to the tree elements. Adding more and more traversal algorithms to the collection gradually blurs its primary responsibility, which is efficient data storage. Additionally, some algorithms might be tailored for a specific application, so including them into a generic collection class would be weird. On the other hand, the client code that’s supposed to work with various collections may not even care how they store their elements. However, since collections all provide different ways of accessing their elements, you have no option other than to couple your code to the specific collection classes.",
    "solution": "The main idea of the Iterator pattern is to extract the traversal behavior of a collection into a separate object called an . In addition to implementing the algorithm itself, an iterator object encapsulates all of the traversal details, such as the current position and how many elements are left till the end. Because of this, several iterators can go through the same collection at the same time, independently of each other. Usually, iterators provide one primary method for fetching elements of the collection. The client can keep running this method until it doesn’t return anything, which means that the iterator has traversed all of the elements. All iterators must implement the same interface. This makes the client code compatible with any collection type or any traversal algorithm as long as there’s a proper iterator. If you need a special way to traverse a collection, you just create a new iterator class, without having to change the collection or the client.",
    "uml_image_url": "https://refactoring.guru/design-patterns/iterator",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The collection interface must declare a factory method for\n// producing iterators. You can declare several methods if there\n// are different kinds of iteration available in your program.\ninterface SocialNetwork is\n    method createFriendsIterator(profileId):ProfileIterator\n    method createCoworkersIterator(profileId):ProfileIterator\n\n\n// Each concrete collection is coupled to a set of concrete\n// iterator classes it returns. But the client isn't, since the\n// signature of these methods returns iterator interfaces.\nclass Facebook implements SocialNetwork is\n    // ... The bulk of the collection's code should go here ...\n\n    // Iterator creation code.\n    method createFriendsIterator(profileId) is\n        return new FacebookIterator(this, profileId, \"friends\")\n    method createCoworkersIterator(profileId) is\n        return new FacebookIterator(this, profileId, \"coworkers\")\n\n\n// The common interface for all iterators.\ninterface ProfileIterator is\n    method getNext():Profile\n    method hasMore():bool\n\n\n// The concrete iterator class.\nclass FacebookIterator implements ProfileIterator is\n    // The iterator needs a reference to the collection that it\n    // traverses.\n    private field facebook: Facebook\n    private field profileId, type: string\n\n    // An iterator object traverses the collection independently\n    // from other iterators. Therefore it has to store the\n    // iteration state.\n    private field currentPosition\n    private field cache: array of Profile\n\n    constructor FacebookIterator(facebook, profileId, type) is\n        this.facebook = facebook\n        this.profileId = profileId\n        this.type = type\n\n    private method lazyInit() is\n        if (cache == null)\n            cache = facebook.socialGraphRequest(profileId, type)\n\n    // Each concrete iterator class has its own implementation\n    // of the common iterator interface.\n    method getNext() is\n        if (hasMore())\n            result = cache[currentPosition]\n            currentPosition++\n            return result\n\n    method hasMore() is\n        lazyInit()\n        return currentPosition < cache.length\n\n\n// Here is another useful trick: you can pass an iterator to a\n// client class instead of giving it access to a whole\n// collection. This way, you don't expose the collection to the\n// client.\n//\n// And there's another benefit: you can change the way the\n// client works with the collection at runtime by passing it a\n// different iterator. This is possible because the client code\n// isn't coupled to concrete iterator classes.\nclass SocialSpammer is\n    method send(iterator: ProfileIterator, message: string) is\n        while (iterator.hasMore())\n            profile = iterator.getNext()\n            System.sendEmail(profile.getEmail(), message)\n\n\n// The application class configures collections and iterators\n// and then passes them to the client code.\nclass Application is\n    field network: SocialNetwork\n    field spammer: SocialSpammer\n\n    method config() is\n        if working with Facebook\n            this.network = new Facebook()\n        if working with LinkedIn\n            this.network = new LinkedIn()\n        this.spammer = new SocialSpammer()\n\n    method sendSpamToFriends(profile) is\n        iterator = network.createFriendsIterator(profile.getId())\n        spammer.send(iterator, \"Very important message\")\n\n    method sendSpamToCoworkers(profile) is\n        iterator = network.createCoworkersIterator(profile.getId())\n        spammer.send(iterator, \"Very important message\")"
      }
    ],
    "id": "iterator",
    "text_for_embedding": "Pattern Name: Iterator. Problem it solves: Collections are one of the most used data types in programming. Nonetheless, a collection is just a container for a group of objects. Most collections store their elements in simple lists. However, some of them are based on stacks, trees, graphs and other complex data structures. But no matter how a collection is structured, it must provide some way of accessing its elements so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over. This may sound like an easy job if you have a collection based on a list. You just loop over all of the elements. But how do you sequentially traverse elements of a complex data structure, such as a tree? For example, one day you might be just fine with depth-first traversal of a tree. Yet the next day you might require breadth-first traversal. And the next week, you might need something else, like random access to the tree elements. Adding more and more traversal algorithms to the collection gradually blurs its primary responsibility, which is efficient data storage. Additionally, some algorithms might be tailored for a specific application, so including them into a generic collection class would be weird. On the other hand, the client code that’s supposed to work with various collections may not even care how they store their elements. However, since collections all provide different ways of accessing their elements, you have no option other than to couple your code to the specific collection classes. Solution: The main idea of the Iterator pattern is to extract the traversal behavior of a collection into a separate object called an . In addition to implementing the algorithm itself, an iterator object encapsulates all of the traversal details, such as the current position and how many elements are left till the end. Because of this, several iterators can go through the same collection at the same time, independently of each other. Usually, iterators provide one primary method for fetching elements of the collection. The client can keep running this method until it doesn’t return anything, which means that the iterator has traversed all of the elements. All iterators must implement the same interface. This makes the client code compatible with any collection type or any traversal algorithm as long as there’s a proper iterator. If you need a special way to traverse a collection, you just create a new iterator class, without having to change the collection or the client."
  },
  {
    "name": "Command",
    "url": "https://refactoring.guru/design-patterns/command",
    "problem": "Imagine that you’re working on a new text-editor app. Your current task is to create a toolbar with a bunch of buttons for various operations of the editor. You created a very neat class that can be used for buttons on the toolbar, as well as for generic buttons in various dialogs. While all of these buttons look similar, they’re all supposed to do different things. Where would you put the code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses for each place where the button is used. These subclasses would contain the code that would have to be executed on a button click. Before long, you realize that this approach is deeply flawed. First, you have an enormous number of subclasses, and that would be okay if you weren’t risking breaking the code in these subclasses each time you modify the base class. Put simply, your GUI code has become awkwardly dependent on the volatile code of the business logic. And here’s the ugliest part. Some operations, such as copying/pasting text, would need to be invoked from multiple places. For example, a user could click a small “Copy” button on the toolbar, or copy something via the context menu, or just hit on the keyboard. Initially, when our app only had the toolbar, it was okay to place the implementation of various operations into the button subclasses. In other words, having the code for copying text inside the subclass was fine. But then, when you implement context menus, shortcuts, and other stuff, you have to either duplicate the operation’s code in many classes or make menus dependent on buttons, which is an even worse option.",
    "solution": "Good software design is often based on the , which usually results in breaking an app into layers. The most common example: a layer for the graphical user interface and another layer for the business logic. The GUI layer is responsible for rendering a beautiful picture on the screen, capturing any input and showing results of what the user and the app are doing. However, when it comes to doing something important, like calculating the trajectory of the moon or composing an annual report, the GUI layer delegates the work to the underlying layer of business logic. In the code it might look like this: a GUI object calls a method of a business logic object, passing it some arguments. This process is usually described as one object sending another a . The Command pattern suggests that GUI objects shouldn’t send these requests directly. Instead, you should extract all of the request details, such as the object being called, the name of the method and the list of arguments into a separate class with a single method that triggers this request. Command objects serve as links between various GUI and business logic objects. From now on, the GUI object doesn’t need to know what business logic object will receive the request and how it’ll be processed. The GUI object just triggers the command, which handles all the details. The next step is to make your commands implement the same interface. Usually it has just a single execution method that takes no parameters. This interface lets you use various commands with the same request sender, without coupling it to concrete classes of commands. As a bonus, now you can switch command objects linked to the sender, effectively changing the sender’s behavior at runtime. You might have noticed one missing piece of the puzzle, which is the request parameters. A GUI object might have supplied the business-layer object with some parameters. Since the command execution method doesn’t have any parameters, how would we pass the request details to the receiver? It turns out the command should be either pre-configured with this data, or capable of getting it on its own. Let’s get back to our text editor. After we apply the Command pattern, we no longer need all those button subclasses to implement various click behaviors. It’s enough to put a single field into the base class that stores a reference to a command object and make the button execute that command on a click. You’ll implement a bunch of command classes for every possible operation and link them with particular buttons, depending on the buttons’ intended behavior. Other GUI elements, such as menus, shortcuts or entire dialogs, can be implemented in the same way. They’ll be linked to a command which gets executed when a user interacts with the GUI element. As you’ve probably guessed by now, the elements related to the same operations will be linked to the same commands, preventing any code duplication. As a result, commands become a convenient middle layer that reduces coupling between the GUI and business logic layers. And that’s only a fraction of the benefits that the Command pattern can offer!",
    "uml_image_url": "https://refactoring.guru/design-patterns/command",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The base command class defines the common interface for all\n// concrete commands.\nabstract class Command is\n    protected field app: Application\n    protected field editor: Editor\n    protected field backup: text\n\n    constructor Command(app: Application, editor: Editor) is\n        this.app = app\n        this.editor = editor\n\n    // Make a backup of the editor's state.\n    method saveBackup() is\n        backup = editor.text\n\n    // Restore the editor's state.\n    method undo() is\n        editor.text = backup\n\n    // The execution method is declared abstract to force all\n    // concrete commands to provide their own implementations.\n    // The method must return true or false depending on whether\n    // the command changes the editor's state.\n    abstract method execute()\n\n\n// The concrete commands go here.\nclass CopyCommand extends Command is\n    // The copy command isn't saved to the history since it\n    // doesn't change the editor's state.\n    method execute() is\n        app.clipboard = editor.getSelection()\n        return false\n\nclass CutCommand extends Command is\n    // The cut command does change the editor's state, therefore\n    // it must be saved to the history. And it'll be saved as\n    // long as the method returns true.\n    method execute() is\n        saveBackup()\n        app.clipboard = editor.getSelection()\n        editor.deleteSelection()\n        return true\n\nclass PasteCommand extends Command is\n    method execute() is\n        saveBackup()\n        editor.replaceSelection(app.clipboard)\n        return true\n\n// The undo operation is also a command.\nclass UndoCommand extends Command is\n    method execute() is\n        app.undo()\n        return false\n\n\n// The global command history is just a stack.\nclass CommandHistory is\n    private field history: array of Command\n\n    // Last in...\n    method push(c: Command) is\n        // Push the command to the end of the history array.\n\n    // ...first out\n    method pop():Command is\n        // Get the most recent command from the history.\n\n\n// The editor class has actual text editing operations. It plays\n// the role of a receiver: all commands end up delegating\n// execution to the editor's methods.\nclass Editor is\n    field text: string\n\n    method getSelection() is\n        // Return selected text.\n\n    method deleteSelection() is\n        // Delete selected text.\n\n    method replaceSelection(text) is\n        // Insert the clipboard's contents at the current\n        // position.\n\n\n// The application class sets up object relations. It acts as a\n// sender: when something needs to be done, it creates a command\n// object and executes it.\nclass Application is\n    field clipboard: string\n    field editors: array of Editors\n    field activeEditor: Editor\n    field history: CommandHistory\n\n    // The code which assigns commands to UI objects may look\n    // like this.\n    method createUI() is\n        // ...\n        copy = function() { executeCommand(\n            new CopyCommand(this, activeEditor)) }\n        copyButton.setCommand(copy)\n        shortcuts.onKeyPress(\"Ctrl+C\", copy)\n\n        cut = function() { executeCommand(\n            new CutCommand(this, activeEditor)) }\n        cutButton.setCommand(cut)\n        shortcuts.onKeyPress(\"Ctrl+X\", cut)\n\n        paste = function() { executeCommand(\n            new PasteCommand(this, activeEditor)) }\n        pasteButton.setCommand(paste)\n        shortcuts.onKeyPress(\"Ctrl+V\", paste)\n\n        undo = function() { executeCommand(\n            new UndoCommand(this, activeEditor)) }\n        undoButton.setCommand(undo)\n        shortcuts.onKeyPress(\"Ctrl+Z\", undo)\n\n    // Execute a command and check whether it has to be added to\n    // the history.\n    method executeCommand(command) is\n        if (command.execute())\n            history.push(command)\n\n    // Take the most recent command from the history and run its\n    // undo method. Note that we don't know the class of that\n    // command. But we don't have to, since the command knows\n    // how to undo its own action.\n    method undo() is\n        command = history.pop()\n        if (command != null)\n            command.undo()"
      }
    ],
    "id": "command",
    "text_for_embedding": "Pattern Name: Command. Problem it solves: Imagine that you’re working on a new text-editor app. Your current task is to create a toolbar with a bunch of buttons for various operations of the editor. You created a very neat class that can be used for buttons on the toolbar, as well as for generic buttons in various dialogs. While all of these buttons look similar, they’re all supposed to do different things. Where would you put the code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses for each place where the button is used. These subclasses would contain the code that would have to be executed on a button click. Before long, you realize that this approach is deeply flawed. First, you have an enormous number of subclasses, and that would be okay if you weren’t risking breaking the code in these subclasses each time you modify the base class. Put simply, your GUI code has become awkwardly dependent on the volatile code of the business logic. And here’s the ugliest part. Some operations, such as copying/pasting text, would need to be invoked from multiple places. For example, a user could click a small “Copy” button on the toolbar, or copy something via the context menu, or just hit on the keyboard. Initially, when our app only had the toolbar, it was okay to place the implementation of various operations into the button subclasses. In other words, having the code for copying text inside the subclass was fine. But then, when you implement context menus, shortcuts, and other stuff, you have to either duplicate the operation’s code in many classes or make menus dependent on buttons, which is an even worse option. Solution: Good software design is often based on the , which usually results in breaking an app into layers. The most common example: a layer for the graphical user interface and another layer for the business logic. The GUI layer is responsible for rendering a beautiful picture on the screen, capturing any input and showing results of what the user and the app are doing. However, when it comes to doing something important, like calculating the trajectory of the moon or composing an annual report, the GUI layer delegates the work to the underlying layer of business logic. In the code it might look like this: a GUI object calls a method of a business logic object, passing it some arguments. This process is usually described as one object sending another a . The Command pattern suggests that GUI objects shouldn’t send these requests directly. Instead, you should extract all of the request details, such as the object being called, the name of the method and the list of arguments into a separate class with a single method that triggers this request. Command objects serve as links between various GUI and business logic objects. From now on, the GUI object doesn’t need to know what business logic object will receive the request and how it’ll be processed. The GUI object just triggers the command, which handles all the details. The next step is to make your commands implement the same interface. Usually it has just a single execution method that takes no parameters. This interface lets you use various commands with the same request sender, without coupling it to concrete classes of commands. As a bonus, now you can switch command objects linked to the sender, effectively changing the sender’s behavior at runtime. You might have noticed one missing piece of the puzzle, which is the request parameters. A GUI object might have supplied the business-layer object with some parameters. Since the command execution method doesn’t have any parameters, how would we pass the request details to the receiver? It turns out the command should be either pre-configured with this data, or capable of getting it on its own. Let’s get back to our text editor. After we apply the Command pattern, we no longer need all those button subclasses to implement various click behaviors. It’s enough to put a single field into the base class that stores a reference to a command object and make the button execute that command on a click. You’ll implement a bunch of command classes for every possible operation and link them with particular buttons, depending on the buttons’ intended behavior. Other GUI elements, such as menus, shortcuts or entire dialogs, can be implemented in the same way. They’ll be linked to a command which gets executed when a user interacts with the GUI element. As you’ve probably guessed by now, the elements related to the same operations will be linked to the same commands, preventing any code duplication. As a result, commands become a convenient middle layer that reduces coupling between the GUI and business logic layers. And that’s only a fraction of the benefits that the Command pattern can offer!"
  },
  {
    "name": "Chain of Responsibility",
    "url": "https://refactoring.guru/design-patterns/chain-of-responsibility",
    "problem": "Imagine that you’re working on an online ordering system. You want to restrict access to the system so only authenticated users can create orders. Also, users who have administrative permissions must have full access to all orders. After a bit of planning, you realized that these checks must be performed sequentially. The application can attempt to authenticate a user to the system whenever it receives a request that contains the user’s credentials. However, if those credentials aren’t correct and authentication fails, there’s no reason to proceed with any other checks. During the next few months, you implemented several more of those sequential checks. The code of the checks, which had already looked like a mess, became more and more bloated as you added each new feature. Changing one check sometimes affected the others. Worst of all, when you tried to reuse the checks to protect other components of the system, you had to duplicate some of the code since those components required some of the checks, but not all of them. The system became very hard to comprehend and expensive to maintain. You struggled with the code for a while, until one day you decided to refactor the whole thing.",
    "solution": "Like many other behavioral design patterns, the relies on transforming particular behaviors into stand-alone objects called . In our case, each check should be extracted to its own class with a single method that performs the check. The request, along with its data, is passed to this method as an argument. The pattern suggests that you link these handlers into a chain. Each linked handler has a field for storing a reference to the next handler in the chain. In addition to processing a request, handlers pass the request further along the chain. The request travels along the chain until all handlers have had a chance to process it. Here’s the best part: a handler can decide not to pass the request further down the chain and effectively stop any further processing. In our example with ordering systems, a handler performs the processing and then decides whether to pass the request further down the chain. Assuming the request contains the right data, all the handlers can execute their primary behavior, whether it’s authentication checks or caching. However, there’s a slightly different approach (and it’s a bit more canonical) in which, upon receiving a request, a handler decides whether it can process it. If it can, it doesn’t pass the request any further. So it’s either only one handler that processes the request or none at all. This approach is very common when dealing with events in stacks of elements within a graphical user interface. For instance, when a user clicks a button, the event propagates through the chain of GUI elements that starts with the button, goes along its containers (like forms or panels), and ends up with the main application window. The event is processed by the first element in the chain that’s capable of handling it. This example is also noteworthy because it shows that a chain can always be extracted from an object tree. It’s crucial that all handler classes implement the same interface. Each concrete handler should only care about the following one having the method. This way you can compose chains at runtime, using various handlers without coupling your code to their concrete classes.",
    "uml_image_url": "https://refactoring.guru/design-patterns/chain-of-responsibility",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The handler interface declares a method for executing a\n// request.\ninterface ComponentWithContextualHelp is\n    method showHelp()\n\n\n// The base class for simple components.\nabstract class Component implements ComponentWithContextualHelp is\n    field tooltipText: string\n\n    // The component's container acts as the next link in the\n    // chain of handlers.\n    protected field container: Container\n\n    // The component shows a tooltip if there's help text\n    // assigned to it. Otherwise it forwards the call to the\n    // container, if it exists.\n    method showHelp() is\n        if (tooltipText != null)\n            // Show tooltip.\n        else\n            container.showHelp()\n\n\n// Containers can contain both simple components and other\n// containers as children. The chain relationships are\n// established here. The class inherits showHelp behavior from\n// its parent.\nabstract class Container extends Component is\n    protected field children: array of Component\n\n    method add(child) is\n        children.add(child)\n        child.container = this\n\n\n// Primitive components may be fine with default help\n// implementation...\nclass Button extends Component is\n    // ...\n\n// But complex components may override the default\n// implementation. If the help text can't be provided in a new\n// way, the component can always call the base implementation\n// (see Component class).\nclass Panel extends Container is\n    field modalHelpText: string\n\n    method showHelp() is\n        if (modalHelpText != null)\n            // Show a modal window with the help text.\n        else\n            super.showHelp()\n\n// ...same as above...\nclass Dialog extends Container is\n    field wikiPageURL: string\n\n    method showHelp() is\n        if (wikiPageURL != null)\n            // Open the wiki help page.\n        else\n            super.showHelp()\n\n\n// Client code.\nclass Application is\n    // Every application configures the chain differently.\n    method createUI() is\n        dialog = new Dialog(\"Budget Reports\")\n        dialog.wikiPageURL = \"http://...\"\n        panel = new Panel(0, 0, 400, 800)\n        panel.modalHelpText = \"This panel does...\"\n        ok = new Button(250, 760, 50, 20, \"OK\")\n        ok.tooltipText = \"This is an OK button that...\"\n        cancel = new Button(320, 760, 50, 20, \"Cancel\")\n        // ...\n        panel.add(ok)\n        panel.add(cancel)\n        dialog.add(panel)\n\n    // Imagine what happens here.\n    method onF1KeyPress() is\n        component = this.getComponentAtMouseCoords()\n        component.showHelp()"
      }
    ],
    "id": "chain-of-responsibility",
    "text_for_embedding": "Pattern Name: Chain of Responsibility. Problem it solves: Imagine that you’re working on an online ordering system. You want to restrict access to the system so only authenticated users can create orders. Also, users who have administrative permissions must have full access to all orders. After a bit of planning, you realized that these checks must be performed sequentially. The application can attempt to authenticate a user to the system whenever it receives a request that contains the user’s credentials. However, if those credentials aren’t correct and authentication fails, there’s no reason to proceed with any other checks. During the next few months, you implemented several more of those sequential checks. The code of the checks, which had already looked like a mess, became more and more bloated as you added each new feature. Changing one check sometimes affected the others. Worst of all, when you tried to reuse the checks to protect other components of the system, you had to duplicate some of the code since those components required some of the checks, but not all of them. The system became very hard to comprehend and expensive to maintain. You struggled with the code for a while, until one day you decided to refactor the whole thing. Solution: Like many other behavioral design patterns, the relies on transforming particular behaviors into stand-alone objects called . In our case, each check should be extracted to its own class with a single method that performs the check. The request, along with its data, is passed to this method as an argument. The pattern suggests that you link these handlers into a chain. Each linked handler has a field for storing a reference to the next handler in the chain. In addition to processing a request, handlers pass the request further along the chain. The request travels along the chain until all handlers have had a chance to process it. Here’s the best part: a handler can decide not to pass the request further down the chain and effectively stop any further processing. In our example with ordering systems, a handler performs the processing and then decides whether to pass the request further down the chain. Assuming the request contains the right data, all the handlers can execute their primary behavior, whether it’s authentication checks or caching. However, there’s a slightly different approach (and it’s a bit more canonical) in which, upon receiving a request, a handler decides whether it can process it. If it can, it doesn’t pass the request any further. So it’s either only one handler that processes the request or none at all. This approach is very common when dealing with events in stacks of elements within a graphical user interface. For instance, when a user clicks a button, the event propagates through the chain of GUI elements that starts with the button, goes along its containers (like forms or panels), and ends up with the main application window. The event is processed by the first element in the chain that’s capable of handling it. This example is also noteworthy because it shows that a chain can always be extracted from an object tree. It’s crucial that all handler classes implement the same interface. Each concrete handler should only care about the following one having the method. This way you can compose chains at runtime, using various handlers without coupling your code to their concrete classes."
  },
  {
    "name": "Proxy",
    "url": "https://refactoring.guru/design-patterns/proxy",
    "problem": "Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always. You could implement lazy initialization: create this object only when it’s actually needed. All of the object’s clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication. In an ideal world, we’d want to put this code directly into our object’s class, but that isn’t always possible. For instance, the class may be part of a closed 3rd-party library.",
    "solution": "The Proxy pattern suggests that you create a new proxy class with the same interface as an original service object. Then you update your app so that it passes the proxy object to all of the original object’s clients. Upon receiving a request from a client, the proxy creates a real service object and delegates all the work to it. But what’s the benefit? If you need to execute something either before or after the primary logic of the class, the proxy lets you do this without changing that class. Since the proxy implements the same interface as the original class, it can be passed to any client that expects a real service object.",
    "uml_image_url": "https://refactoring.guru/design-patterns/proxy",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The interface of a remote service.\ninterface ThirdPartyYouTubeLib is\n    method listVideos()\n    method getVideoInfo(id)\n    method downloadVideo(id)\n\n// The concrete implementation of a service connector. Methods\n// of this class can request information from YouTube. The speed\n// of the request depends on a user's internet connection as\n// well as YouTube's. The application will slow down if a lot of\n// requests are fired at the same time, even if they all request\n// the same information.\nclass ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib is\n    method listVideos() is\n        // Send an API request to YouTube.\n\n    method getVideoInfo(id) is\n        // Get metadata about some video.\n\n    method downloadVideo(id) is\n        // Download a video file from YouTube.\n\n// To save some bandwidth, we can cache request results and keep\n// them for some time. But it may be impossible to put such code\n// directly into the service class. For example, it could have\n// been provided as part of a third party library and/or defined\n// as `final`. That's why we put the caching code into a new\n// proxy class which implements the same interface as the\n// service class. It delegates to the service object only when\n// the real requests have to be sent.\nclass CachedYouTubeClass implements ThirdPartyYouTubeLib is\n    private field service: ThirdPartyYouTubeLib\n    private field listCache, videoCache\n    field needReset\n\n    constructor CachedYouTubeClass(service: ThirdPartyYouTubeLib) is\n        this.service = service\n\n    method listVideos() is\n        if (listCache == null || needReset)\n            listCache = service.listVideos()\n        return listCache\n\n    method getVideoInfo(id) is\n        if (videoCache == null || needReset)\n            videoCache = service.getVideoInfo(id)\n        return videoCache\n\n    method downloadVideo(id) is\n        if (!downloadExists(id) || needReset)\n            service.downloadVideo(id)\n\n// The GUI class, which used to work directly with a service\n// object, stays unchanged as long as it works with the service\n// object through an interface. We can safely pass a proxy\n// object instead of a real service object since they both\n// implement the same interface.\nclass YouTubeManager is\n    protected field service: ThirdPartyYouTubeLib\n\n    constructor YouTubeManager(service: ThirdPartyYouTubeLib) is\n        this.service = service\n\n    method renderVideoPage(id) is\n        info = service.getVideoInfo(id)\n        // Render the video page.\n\n    method renderListPanel() is\n        list = service.listVideos()\n        // Render the list of video thumbnails.\n\n    method reactOnUserInput() is\n        renderVideoPage()\n        renderListPanel()\n\n// The application can configure proxies on the fly.\nclass Application is\n    method init() is\n        aYouTubeService = new ThirdPartyYouTubeClass()\n        aYouTubeProxy = new CachedYouTubeClass(aYouTubeService)\n        manager = new YouTubeManager(aYouTubeProxy)\n        manager.reactOnUserInput()"
      }
    ],
    "id": "proxy",
    "text_for_embedding": "Pattern Name: Proxy. Problem it solves: Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always. You could implement lazy initialization: create this object only when it’s actually needed. All of the object’s clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication. In an ideal world, we’d want to put this code directly into our object’s class, but that isn’t always possible. For instance, the class may be part of a closed 3rd-party library. Solution: The Proxy pattern suggests that you create a new proxy class with the same interface as an original service object. Then you update your app so that it passes the proxy object to all of the original object’s clients. Upon receiving a request from a client, the proxy creates a real service object and delegates all the work to it. But what’s the benefit? If you need to execute something either before or after the primary logic of the class, the proxy lets you do this without changing that class. Since the proxy implements the same interface as the original class, it can be passed to any client that expects a real service object."
  },
  {
    "name": "Flyweight",
    "url": "https://refactoring.guru/design-patterns/flyweight",
    "problem": "To have some fun after long working hours, you decided to create a simple video game: players would be moving around a map and shooting each other. You chose to implement a realistic particle system and make it a distinctive feature of the game. Vast quantities of bullets, missiles, and shrapnel from explosions should fly all over the map and deliver a thrilling experience to the player. Upon its completion, you pushed the last commit, built the game and sent it to your friend for a test drive. Although the game was running flawlessly on your machine, your friend wasn’t able to play for long. On his computer, the game kept crashing after a few minutes of gameplay. After spending several hours digging through debug logs, you discovered that the game crashed because of an insufficient amount of RAM. It turned out that your friend’s rig was much less powerful than your own computer, and that’s why the problem emerged so quickly on his machine. The actual problem was related to your particle system. Each particle, such as a bullet, a missile or a piece of shrapnel was represented by a separate object containing plenty of data. At some point, when the carnage on a player’s screen reached its climax, newly created particles no longer fit into the remaining RAM, so the program crashed.",
    "solution": "On closer inspection of the class, you may notice that the color and fields consume a lot more memory than other fields. What’s worse is that these two fields store almost identical data across all particles. For example, all bullets have the same color and sprite. Other parts of a particle’s state, such as coordinates, movement vector and speed, are unique to each particle. After all, the values of these fields change over time. This data represents the always changing context in which the particle exists, while the color and sprite remain constant for each particle. This constant data of an object is usually called the . It lives within the object; other objects can only read it, not change it. The rest of the object’s state, often altered “from the outside” by other objects, is called the . The Flyweight pattern suggests that you stop storing the extrinsic state inside the object. Instead, you should pass this state to specific methods which rely on it. Only the intrinsic state stays within the object, letting you reuse it in different contexts. As a result, you’d need fewer of these objects since they only differ in the intrinsic state, which has much fewer variations than the extrinsic. Let’s return to our game. Assuming that we had extracted the extrinsic state from our particle class, only three different objects would suffice to represent all particles in the game: a bullet, a missile, and a piece of shrapnel. As you’ve probably guessed by now, an object that only stores the intrinsic state is called . Where does the extrinsic state move to? Some class should still store it, right? In most cases, it gets moved to the container object, which aggregates objects before we apply the pattern. In our case, that’s the main object that stores all particles in the field. To move the extrinsic state into this class, you need to create several array fields for storing coordinates, vectors, and speed of each individual particle. But that’s not all. You need another array for storing references to a specific flyweight that represents a particle. These arrays must be in sync so that you can access all data of a particle using the same index. A more elegant solution is to create a separate context class that would store the extrinsic state along with reference to the flyweight object. This approach would require having just a single array in the container class. Wait a second! Won’t we need to have as many of these contextual objects as we had at the very beginning? Technically, yes. But the thing is, these objects are much smaller than before. The most memory-consuming fields have been moved to just a few flyweight objects. Now, a thousand small contextual objects can reuse a single heavy flyweight object instead of storing a thousand copies of its data. Since the same flyweight object can be used in different contexts, you have to make sure that its state can’t be modified. A flyweight should initialize its state just once, via constructor parameters. It shouldn’t expose any setters or public fields to other objects. For more convenient access to various flyweights, you can create a factory method that manages a pool of existing flyweight objects. The method accepts the intrinsic state of the desired flyweight from a client, looks for an existing flyweight object matching this state, and returns it if it was found. If not, it creates a new flyweight and adds it to the pool. There are several options where this method could be placed. The most obvious place is a flyweight container. Alternatively, you could create a new factory class. Or you could make the factory method static and put it inside an actual flyweight class.",
    "uml_image_url": "https://refactoring.guru/design-patterns/flyweight",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The flyweight class contains a portion of the state of a\n// tree. These fields store values that are unique for each\n// particular tree. For instance, you won't find here the tree\n// coordinates. But the texture and colors shared between many\n// trees are here. Since this data is usually BIG, you'd waste a\n// lot of memory by keeping it in each tree object. Instead, we\n// can extract texture, color and other repeating data into a\n// separate object which lots of individual tree objects can\n// reference.\nclass TreeType is\n    field name\n    field color\n    field texture\n    constructor TreeType(name, color, texture) { ... }\n    method draw(canvas, x, y) is\n        // 1. Create a bitmap of a given type, color & texture.\n        // 2. Draw the bitmap on the canvas at X and Y coords.\n\n// Flyweight factory decides whether to re-use existing\n// flyweight or to create a new object.\nclass TreeFactory is\n    static field treeTypes: collection of tree types\n    static method getTreeType(name, color, texture) is\n        type = treeTypes.find(name, color, texture)\n        if (type == null)\n            type = new TreeType(name, color, texture)\n            treeTypes.add(type)\n        return type\n\n// The contextual object contains the extrinsic part of the tree\n// state. An application can create billions of these since they\n// are pretty small: just two integer coordinates and one\n// reference field.\nclass Tree is\n    field x,y\n    field type: TreeType\n    constructor Tree(x, y, type) { ... }\n    method draw(canvas) is\n        type.draw(canvas, this.x, this.y)\n\n// The Tree and the Forest classes are the flyweight's clients.\n// You can merge them if you don't plan to develop the Tree\n// class any further.\nclass Forest is\n    field trees: collection of Trees\n\n    method plantTree(x, y, name, color, texture) is\n        type = TreeFactory.getTreeType(name, color, texture)\n        tree = new Tree(x, y, type)\n        trees.add(tree)\n\n    method draw(canvas) is\n        foreach (tree in trees) do\n            tree.draw(canvas)"
      }
    ],
    "id": "flyweight",
    "text_for_embedding": "Pattern Name: Flyweight. Problem it solves: To have some fun after long working hours, you decided to create a simple video game: players would be moving around a map and shooting each other. You chose to implement a realistic particle system and make it a distinctive feature of the game. Vast quantities of bullets, missiles, and shrapnel from explosions should fly all over the map and deliver a thrilling experience to the player. Upon its completion, you pushed the last commit, built the game and sent it to your friend for a test drive. Although the game was running flawlessly on your machine, your friend wasn’t able to play for long. On his computer, the game kept crashing after a few minutes of gameplay. After spending several hours digging through debug logs, you discovered that the game crashed because of an insufficient amount of RAM. It turned out that your friend’s rig was much less powerful than your own computer, and that’s why the problem emerged so quickly on his machine. The actual problem was related to your particle system. Each particle, such as a bullet, a missile or a piece of shrapnel was represented by a separate object containing plenty of data. At some point, when the carnage on a player’s screen reached its climax, newly created particles no longer fit into the remaining RAM, so the program crashed. Solution: On closer inspection of the class, you may notice that the color and fields consume a lot more memory than other fields. What’s worse is that these two fields store almost identical data across all particles. For example, all bullets have the same color and sprite. Other parts of a particle’s state, such as coordinates, movement vector and speed, are unique to each particle. After all, the values of these fields change over time. This data represents the always changing context in which the particle exists, while the color and sprite remain constant for each particle. This constant data of an object is usually called the . It lives within the object; other objects can only read it, not change it. The rest of the object’s state, often altered “from the outside” by other objects, is called the . The Flyweight pattern suggests that you stop storing the extrinsic state inside the object. Instead, you should pass this state to specific methods which rely on it. Only the intrinsic state stays within the object, letting you reuse it in different contexts. As a result, you’d need fewer of these objects since they only differ in the intrinsic state, which has much fewer variations than the extrinsic. Let’s return to our game. Assuming that we had extracted the extrinsic state from our particle class, only three different objects would suffice to represent all particles in the game: a bullet, a missile, and a piece of shrapnel. As you’ve probably guessed by now, an object that only stores the intrinsic state is called . Where does the extrinsic state move to? Some class should still store it, right? In most cases, it gets moved to the container object, which aggregates objects before we apply the pattern. In our case, that’s the main object that stores all particles in the field. To move the extrinsic state into this class, you need to create several array fields for storing coordinates, vectors, and speed of each individual particle. But that’s not all. You need another array for storing references to a specific flyweight that represents a particle. These arrays must be in sync so that you can access all data of a particle using the same index. A more elegant solution is to create a separate context class that would store the extrinsic state along with reference to the flyweight object. This approach would require having just a single array in the container class. Wait a second! Won’t we need to have as many of these contextual objects as we had at the very beginning? Technically, yes. But the thing is, these objects are much smaller than before. The most memory-consuming fields have been moved to just a few flyweight objects. Now, a thousand small contextual objects can reuse a single heavy flyweight object instead of storing a thousand copies of its data. Since the same flyweight object can be used in different contexts, you have to make sure that its state can’t be modified. A flyweight should initialize its state just once, via constructor parameters. It shouldn’t expose any setters or public fields to other objects. For more convenient access to various flyweights, you can create a factory method that manages a pool of existing flyweight objects. The method accepts the intrinsic state of the desired flyweight from a client, looks for an existing flyweight object matching this state, and returns it if it was found. If not, it creates a new flyweight and adds it to the pool. There are several options where this method could be placed. The most obvious place is a flyweight container. Alternatively, you could create a new factory class. Or you could make the factory method static and put it inside an actual flyweight class."
  },
  {
    "name": "Facade",
    "url": "https://refactoring.guru/design-patterns/facade",
    "problem": "Imagine that you must make your code work with a broad set of objects that belong to a sophisticated library or framework. Ordinarily, you’d need to initialize all of those objects, keep track of dependencies, execute methods in the correct order, and so on. As a result, the business logic of your classes would become tightly coupled to the implementation details of 3rd-party classes, making it hard to comprehend and maintain.",
    "solution": "A facade is a class that provides a simple interface to a complex subsystem which contains lots of moving parts. A facade might provide limited functionality in comparison to working with the subsystem directly. However, it includes only those features that clients really care about. Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality. For instance, an app that uploads short funny videos with cats to social media could potentially use a professional video conversion library. However, all that it really needs is a class with the single method . After creating such a class and connecting it with the video conversion library, you’ll have your first facade.",
    "uml_image_url": "https://refactoring.guru/design-patterns/facade",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// These are some of the classes of a complex 3rd-party video\n// conversion framework. We don't control that code, therefore\n// can't simplify it.\n\nclass VideoFile\n// ...\n\nclass OggCompressionCodec\n// ...\n\nclass MPEG4CompressionCodec\n// ...\n\nclass CodecFactory\n// ...\n\nclass BitrateReader\n// ...\n\nclass AudioMixer\n// ...\n\n\n// We create a facade class to hide the framework's complexity\n// behind a simple interface. It's a trade-off between\n// functionality and simplicity.\nclass VideoConverter is\n    method convert(filename, format):File is\n        file = new VideoFile(filename)\n        sourceCodec = (new CodecFactory).extract(file)\n        if (format == \"mp4\")\n            destinationCodec = new MPEG4CompressionCodec()\n        else\n            destinationCodec = new OggCompressionCodec()\n        buffer = BitrateReader.read(filename, sourceCodec)\n        result = BitrateReader.convert(buffer, destinationCodec)\n        result = (new AudioMixer()).fix(result)\n        return new File(result)\n\n// Application classes don't depend on a billion classes\n// provided by the complex framework. Also, if you decide to\n// switch frameworks, you only need to rewrite the facade class.\nclass Application is\n    method main() is\n        convertor = new VideoConverter()\n        mp4 = convertor.convert(\"funny-cats-video.ogg\", \"mp4\")\n        mp4.save()"
      }
    ],
    "id": "facade",
    "text_for_embedding": "Pattern Name: Facade. Problem it solves: Imagine that you must make your code work with a broad set of objects that belong to a sophisticated library or framework. Ordinarily, you’d need to initialize all of those objects, keep track of dependencies, execute methods in the correct order, and so on. As a result, the business logic of your classes would become tightly coupled to the implementation details of 3rd-party classes, making it hard to comprehend and maintain. Solution: A facade is a class that provides a simple interface to a complex subsystem which contains lots of moving parts. A facade might provide limited functionality in comparison to working with the subsystem directly. However, it includes only those features that clients really care about. Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality. For instance, an app that uploads short funny videos with cats to social media could potentially use a professional video conversion library. However, all that it really needs is a class with the single method . After creating such a class and connecting it with the video conversion library, you’ll have your first facade."
  },
  {
    "name": "Decorator",
    "url": "https://refactoring.guru/design-patterns/decorator",
    "problem": "Imagine that you’re working on a notification library which lets other programs notify their users about important events. The initial version of the library was based on the class that had only a few fields, a constructor and a single method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once, and then use it each time something important happened. At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications. How hard can that be? You extended the class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications. But then someone reasonably asked you, “Why can’t you use several notification types at once? If your house is on fire, you’d probably want to be informed through every channel.” You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well. You have to find some other way to structure notifications classes so that their number won’t accidentally break some Guinness record.",
    "solution": "Extending a class is the first thing that comes to mind when you need to alter an object’s behavior. However, inheritance has several serious caveats that you need to be aware of. One of the ways to overcome these caveats is by using or instead of . Both of the alternatives work almost the same way: one object reference to another and delegates it some work, whereas with inheritance, the object itself able to do that work, inheriting the behavior from its superclass. With this new approach you can easily substitute the linked “helper” object with another, changing the behavior of the container at runtime. An object can use the behavior of various classes, having references to multiple objects and delegating them all kinds of work. Aggregation/composition is the key principle behind many design patterns, including Decorator. On that note, let’s return to the pattern discussion. “Wrapper” is the alternative nickname for the Decorator pattern that clearly expresses the main idea of the pattern. A is an object that can be linked with some object. The wrapper contains the same set of methods as the target and delegates to it all requests it receives. However, the wrapper may alter the result by doing something either before or after it passes the request to the target. When does a simple wrapper become the real decorator? As I mentioned, the wrapper implements the same interface as the wrapped object. That’s why from the client’s perspective these objects are identical. Make the wrapper’s reference field accept any object that follows that interface. This will let you cover an object in multiple wrappers, adding the combined behavior of all the wrappers to it. In our notifications example, let’s leave the simple email notification behavior inside the base class, but turn all other notification methods into decorators. The client code would need to wrap a basic notifier object into a set of decorators that match the client’s preferences. The resulting objects will be structured as a stack. The last decorator in the stack would be the object that the client actually works with. Since all decorators implement the same interface as the base notifier, the rest of the client code won’t care whether it works with the “pure” notifier object or the decorated one. We could apply the same approach to other behaviors such as formatting messages or composing the recipient list. The client can decorate the object with any custom decorators, as long as they follow the same interface as the others.",
    "uml_image_url": "https://refactoring.guru/design-patterns/decorator",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The component interface defines operations that can be\n// altered by decorators.\ninterface DataSource is\n    method writeData(data)\n    method readData():data\n\n// Concrete components provide default implementations for the\n// operations. There might be several variations of these\n// classes in a program.\nclass FileDataSource implements DataSource is\n    constructor FileDataSource(filename) { ... }\n\n    method writeData(data) is\n        // Write data to file.\n\n    method readData():data is\n        // Read data from file.\n\n// The base decorator class follows the same interface as the\n// other components. The primary purpose of this class is to\n// define the wrapping interface for all concrete decorators.\n// The default implementation of the wrapping code might include\n// a field for storing a wrapped component and the means to\n// initialize it.\nclass DataSourceDecorator implements DataSource is\n    protected field wrappee: DataSource\n\n    constructor DataSourceDecorator(source: DataSource) is\n        wrappee = source\n\n    // The base decorator simply delegates all work to the\n    // wrapped component. Extra behaviors can be added in\n    // concrete decorators.\n    method writeData(data) is\n        wrappee.writeData(data)\n\n    // Concrete decorators may call the parent implementation of\n    // the operation instead of calling the wrapped object\n    // directly. This approach simplifies extension of decorator\n    // classes.\n    method readData():data is\n        return wrappee.readData()\n\n// Concrete decorators must call methods on the wrapped object,\n// but may add something of their own to the result. Decorators\n// can execute the added behavior either before or after the\n// call to a wrapped object.\nclass EncryptionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. Encrypt passed data.\n        // 2. Pass encrypted data to the wrappee's writeData\n        // method.\n\n    method readData():data is\n        // 1. Get data from the wrappee's readData method.\n        // 2. Try to decrypt it if it's encrypted.\n        // 3. Return the result.\n\n// You can wrap objects in several layers of decorators.\nclass CompressionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. Compress passed data.\n        // 2. Pass compressed data to the wrappee's writeData\n        // method.\n\n    method readData():data is\n        // 1. Get data from the wrappee's readData method.\n        // 2. Try to decompress it if it's compressed.\n        // 3. Return the result.\n\n\n// Option 1. A simple example of a decorator assembly.\nclass Application is\n    method dumbUsageExample() is\n        source = new FileDataSource(\"somefile.dat\")\n        source.writeData(salaryRecords)\n        // The target file has been written with plain data.\n\n        source = new CompressionDecorator(source)\n        source.writeData(salaryRecords)\n        // The target file has been written with compressed\n        // data.\n\n        source = new EncryptionDecorator(source)\n        // The source variable now contains this:\n        // Encryption > Compression > FileDataSource\n        source.writeData(salaryRecords)\n        // The file has been written with compressed and\n        // encrypted data.\n\n\n// Option 2. Client code that uses an external data source.\n// SalaryManager objects neither know nor care about data\n// storage specifics. They work with a pre-configured data\n// source received from the app configurator.\nclass SalaryManager is\n    field source: DataSource\n\n    constructor SalaryManager(source: DataSource) { ... }\n\n    method load() is\n        return source.readData()\n\n    method save() is\n        source.writeData(salaryRecords)\n    // ...Other useful methods...\n\n\n// The app can assemble different stacks of decorators at\n// runtime, depending on the configuration or environment.\nclass ApplicationConfigurator is\n    method configurationExample() is\n        source = new FileDataSource(\"salary.dat\")\n        if (enabledEncryption)\n            source = new EncryptionDecorator(source)\n        if (enabledCompression)\n            source = new CompressionDecorator(source)\n\n        logger = new SalaryManager(source)\n        salary = logger.load()\n    // ..."
      }
    ],
    "id": "decorator",
    "text_for_embedding": "Pattern Name: Decorator. Problem it solves: Imagine that you’re working on a notification library which lets other programs notify their users about important events. The initial version of the library was based on the class that had only a few fields, a constructor and a single method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once, and then use it each time something important happened. At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications. How hard can that be? You extended the class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications. But then someone reasonably asked you, “Why can’t you use several notification types at once? If your house is on fire, you’d probably want to be informed through every channel.” You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well. You have to find some other way to structure notifications classes so that their number won’t accidentally break some Guinness record. Solution: Extending a class is the first thing that comes to mind when you need to alter an object’s behavior. However, inheritance has several serious caveats that you need to be aware of. One of the ways to overcome these caveats is by using or instead of . Both of the alternatives work almost the same way: one object reference to another and delegates it some work, whereas with inheritance, the object itself able to do that work, inheriting the behavior from its superclass. With this new approach you can easily substitute the linked “helper” object with another, changing the behavior of the container at runtime. An object can use the behavior of various classes, having references to multiple objects and delegating them all kinds of work. Aggregation/composition is the key principle behind many design patterns, including Decorator. On that note, let’s return to the pattern discussion. “Wrapper” is the alternative nickname for the Decorator pattern that clearly expresses the main idea of the pattern. A is an object that can be linked with some object. The wrapper contains the same set of methods as the target and delegates to it all requests it receives. However, the wrapper may alter the result by doing something either before or after it passes the request to the target. When does a simple wrapper become the real decorator? As I mentioned, the wrapper implements the same interface as the wrapped object. That’s why from the client’s perspective these objects are identical. Make the wrapper’s reference field accept any object that follows that interface. This will let you cover an object in multiple wrappers, adding the combined behavior of all the wrappers to it. In our notifications example, let’s leave the simple email notification behavior inside the base class, but turn all other notification methods into decorators. The client code would need to wrap a basic notifier object into a set of decorators that match the client’s preferences. The resulting objects will be structured as a stack. The last decorator in the stack would be the object that the client actually works with. Since all decorators implement the same interface as the base notifier, the rest of the client code won’t care whether it works with the “pure” notifier object or the decorated one. We could apply the same approach to other behaviors such as formatting messages or composing the recipient list. The client can decorate the object with any custom decorators, as long as they follow the same interface as the others."
  },
  {
    "name": "Composite",
    "url": "https://refactoring.guru/design-patterns/composite",
    "problem": "Using the Composite pattern makes sense only when the core model of your app can be represented as a tree. For example, imagine that you have two types of objects: and . A can contain several as well as a number of smaller . These little can also hold some or even smaller , and so on. Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products...and other boxes. How would you determine the total price of such an order? You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it’s not as simple as running a loop. You have to know the classes of and you’re going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible.",
    "solution": "The Composite pattern suggests that you work with and through a common interface which declares a method for calculating the total price. How would this method work? For a product, it’d simply return the product’s price. For a box, it’d go over each item the box contains, ask its price and then return a total for this box. If one of these items were a smaller box, that box would also start going over its contents and so on, until the prices of all inner components were calculated. A box could even add some extra cost to the final price, such as packaging cost. The greatest benefit of this approach is that you don’t need to care about the concrete classes of objects that compose the tree. You don’t need to know whether an object is a simple product or a sophisticated box. You can treat them all the same via the common interface. When you call a method, the objects themselves pass the request down the tree.",
    "uml_image_url": "https://refactoring.guru/design-patterns/composite",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The component interface declares common operations for both\n// simple and complex objects of a composition.\ninterface Graphic is\n    method move(x, y)\n    method draw()\n\n// The leaf class represents end objects of a composition. A\n// leaf object can't have any sub-objects. Usually, it's leaf\n// objects that do the actual work, while composite objects only\n// delegate to their sub-components.\nclass Dot implements Graphic is\n    field x, y\n\n    constructor Dot(x, y) { ... }\n\n    method move(x, y) is\n        this.x += x, this.y += y\n\n    method draw() is\n        // Draw a dot at X and Y.\n\n// All component classes can extend other components.\nclass Circle extends Dot is\n    field radius\n\n    constructor Circle(x, y, radius) { ... }\n\n    method draw() is\n        // Draw a circle at X and Y with radius R.\n\n// The composite class represents complex components that may\n// have children. Composite objects usually delegate the actual\n// work to their children and then \"sum up\" the result.\nclass CompoundGraphic implements Graphic is\n    field children: array of Graphic\n\n    // A composite object can add or remove other components\n    // (both simple or complex) to or from its child list.\n    method add(child: Graphic) is\n        // Add a child to the array of children.\n\n    method remove(child: Graphic) is\n        // Remove a child from the array of children.\n\n    method move(x, y) is\n        foreach (child in children) do\n            child.move(x, y)\n\n    // A composite executes its primary logic in a particular\n    // way. It traverses recursively through all its children,\n    // collecting and summing up their results. Since the\n    // composite's children pass these calls to their own\n    // children and so forth, the whole object tree is traversed\n    // as a result.\n    method draw() is\n        // 1. For each child component:\n        //     - Draw the component.\n        //     - Update the bounding rectangle.\n        // 2. Draw a dashed rectangle using the bounding\n        // coordinates.\n\n\n// The client code works with all the components via their base\n// interface. This way the client code can support simple leaf\n// components as well as complex composites.\nclass ImageEditor is\n    field all: CompoundGraphic\n\n    method load() is\n        all = new CompoundGraphic()\n        all.add(new Dot(1, 2))\n        all.add(new Circle(5, 3, 10))\n        // ...\n\n    // Combine selected components into one complex composite\n    // component.\n    method groupSelected(components: array of Graphic) is\n        group = new CompoundGraphic()\n        foreach (component in components) do\n            group.add(component)\n            all.remove(component)\n        all.add(group)\n        // All components will be drawn.\n        all.draw()"
      }
    ],
    "id": "composite",
    "text_for_embedding": "Pattern Name: Composite. Problem it solves: Using the Composite pattern makes sense only when the core model of your app can be represented as a tree. For example, imagine that you have two types of objects: and . A can contain several as well as a number of smaller . These little can also hold some or even smaller , and so on. Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products...and other boxes. How would you determine the total price of such an order? You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it’s not as simple as running a loop. You have to know the classes of and you’re going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible. Solution: The Composite pattern suggests that you work with and through a common interface which declares a method for calculating the total price. How would this method work? For a product, it’d simply return the product’s price. For a box, it’d go over each item the box contains, ask its price and then return a total for this box. If one of these items were a smaller box, that box would also start going over its contents and so on, until the prices of all inner components were calculated. A box could even add some extra cost to the final price, such as packaging cost. The greatest benefit of this approach is that you don’t need to care about the concrete classes of objects that compose the tree. You don’t need to know whether an object is a simple product or a sophisticated box. You can treat them all the same via the common interface. When you call a method, the objects themselves pass the request down the tree."
  },
  {
    "name": "Bridge",
    "url": "https://refactoring.guru/design-patterns/bridge",
    "problem": "Sound scary? Stay calm and let’s consider a simple example. Say you have a geometric class with a pair of subclasses: and . You want to extend this class hierarchy to incorporate colors, so you plan to create and shape subclasses. However, since you already have two subclasses, you’ll need to create four class combinations such as and . Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you’d need to introduce two subclasses, one for each color. And after that, adding a new color would require creating three subclasses, one for each shape type. The further we go, the worse it becomes.",
    "solution": "This problem occurs because we’re trying to extend the shape classes in two independent dimensions: by form and by color. That’s a very common issue with class inheritance. The Bridge pattern attempts to solve this problem by switching from inheritance to the object composition. What this means is that you extract one of the dimensions into a separate class hierarchy, so that the original classes will reference an object of the new hierarchy, instead of having all of its state and behaviors within one class. Following this approach, we can extract the color-related code into its own class with two subclasses: and . The class then gets a reference field pointing to one of the color objects. Now the shape can delegate any color-related work to the linked color object. That reference will act as a bridge between the and classes. From now on, adding new colors won’t require changing the shape hierarchy, and vice versa. The GoF book introduces the terms and as part of the Bridge definition. In my opinion, the terms sound too academic and make the pattern seem more complicated than it really is. Having read the simple example with shapes and colors, let’s decipher the meaning behind the GoF book’s scary words. (also called ) is a high-level control layer for some entity. This layer isn’t supposed to do any real work on its own. It should delegate the work to the layer (also called ). Note that we’re not talking about or from your programming language. These aren’t the same things. When talking about real applications, the abstraction can be represented by a graphical user interface (GUI), and the implementation could be the underlying operating system code (API) which the GUI layer calls in response to user interactions. Generally speaking, you can extend such an app in two independent directions: In a worst-case scenario, this app might look like a giant spaghetti bowl, where hundreds of conditionals connect different types of GUI with various APIs all over the code. You can bring order to this chaos by extracting the code related to specific interface-platform combinations into separate classes. However, soon you’ll discover that there are of these classes. The class hierarchy will grow exponentially because adding a new GUI or supporting a different API would require creating more and more classes. Let’s try to solve this issue with the Bridge pattern. It suggests that we divide the classes into two hierarchies: The abstraction object controls the appearance of the app, delegating the actual work to the linked implementation object. Different implementations are interchangeable as long as they follow a common interface, enabling the same GUI to work under Windows and Linux. As a result, you can change the GUI classes without touching the API-related classes. Moreover, adding support for another operating system only requires creating a subclass in the implementation hierarchy.",
    "uml_image_url": "https://refactoring.guru/design-patterns/bridge",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The \"abstraction\" defines the interface for the \"control\"\n// part of the two class hierarchies. It maintains a reference\n// to an object of the \"implementation\" hierarchy and delegates\n// all of the real work to this object.\nclass RemoteControl is\n    protected field device: Device\n    constructor RemoteControl(device: Device) is\n        this.device = device\n    method togglePower() is\n        if (device.isEnabled()) then\n            device.disable()\n        else\n            device.enable()\n    method volumeDown() is\n        device.setVolume(device.getVolume() - 10)\n    method volumeUp() is\n        device.setVolume(device.getVolume() + 10)\n    method channelDown() is\n        device.setChannel(device.getChannel() - 1)\n    method channelUp() is\n        device.setChannel(device.getChannel() + 1)\n\n\n// You can extend classes from the abstraction hierarchy\n// independently from device classes.\nclass AdvancedRemoteControl extends RemoteControl is\n    method mute() is\n        device.setVolume(0)\n\n\n// The \"implementation\" interface declares methods common to all\n// concrete implementation classes. It doesn't have to match the\n// abstraction's interface. In fact, the two interfaces can be\n// entirely different. Typically the implementation interface\n// provides only primitive operations, while the abstraction\n// defines higher-level operations based on those primitives.\ninterface Device is\n    method isEnabled()\n    method enable()\n    method disable()\n    method getVolume()\n    method setVolume(percent)\n    method getChannel()\n    method setChannel(channel)\n\n\n// All devices follow the same interface.\nclass Tv implements Device is\n    // ...\n\nclass Radio implements Device is\n    // ...\n\n\n// Somewhere in client code.\ntv = new Tv()\nremote = new RemoteControl(tv)\nremote.togglePower()\n\nradio = new Radio()\nremote = new AdvancedRemoteControl(radio)"
      }
    ],
    "id": "bridge",
    "text_for_embedding": "Pattern Name: Bridge. Problem it solves: Sound scary? Stay calm and let’s consider a simple example. Say you have a geometric class with a pair of subclasses: and . You want to extend this class hierarchy to incorporate colors, so you plan to create and shape subclasses. However, since you already have two subclasses, you’ll need to create four class combinations such as and . Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you’d need to introduce two subclasses, one for each color. And after that, adding a new color would require creating three subclasses, one for each shape type. The further we go, the worse it becomes. Solution: This problem occurs because we’re trying to extend the shape classes in two independent dimensions: by form and by color. That’s a very common issue with class inheritance. The Bridge pattern attempts to solve this problem by switching from inheritance to the object composition. What this means is that you extract one of the dimensions into a separate class hierarchy, so that the original classes will reference an object of the new hierarchy, instead of having all of its state and behaviors within one class. Following this approach, we can extract the color-related code into its own class with two subclasses: and . The class then gets a reference field pointing to one of the color objects. Now the shape can delegate any color-related work to the linked color object. That reference will act as a bridge between the and classes. From now on, adding new colors won’t require changing the shape hierarchy, and vice versa. The GoF book introduces the terms and as part of the Bridge definition. In my opinion, the terms sound too academic and make the pattern seem more complicated than it really is. Having read the simple example with shapes and colors, let’s decipher the meaning behind the GoF book’s scary words. (also called ) is a high-level control layer for some entity. This layer isn’t supposed to do any real work on its own. It should delegate the work to the layer (also called ). Note that we’re not talking about or from your programming language. These aren’t the same things. When talking about real applications, the abstraction can be represented by a graphical user interface (GUI), and the implementation could be the underlying operating system code (API) which the GUI layer calls in response to user interactions. Generally speaking, you can extend such an app in two independent directions: In a worst-case scenario, this app might look like a giant spaghetti bowl, where hundreds of conditionals connect different types of GUI with various APIs all over the code. You can bring order to this chaos by extracting the code related to specific interface-platform combinations into separate classes. However, soon you’ll discover that there are of these classes. The class hierarchy will grow exponentially because adding a new GUI or supporting a different API would require creating more and more classes. Let’s try to solve this issue with the Bridge pattern. It suggests that we divide the classes into two hierarchies: The abstraction object controls the appearance of the app, delegating the actual work to the linked implementation object. Different implementations are interchangeable as long as they follow a common interface, enabling the same GUI to work under Windows and Linux. As a result, you can change the GUI classes without touching the API-related classes. Moreover, adding support for another operating system only requires creating a subclass in the implementation hierarchy."
  },
  {
    "name": "Adapter",
    "url": "https://refactoring.guru/design-patterns/adapter",
    "problem": "Imagine that you’re creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user. At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But there’s a catch: the analytics library only works with data in JSON format. You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the library’s source code in the first place, making this approach impossible.",
    "solution": "You can create an . This is a special object that converts the interface of one object so that another object can understand it. An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isn’t even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles. Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Here’s how it works: Sometimes it’s even possible to create a two-way adapter that can convert the calls in both directions. Let’s get back to our stock market app. To solve the dilemma of incompatible formats, you can create XML-to-JSON adapters for every class of the analytics library that your code works with directly. Then you adjust your code to communicate with the library only via these adapters. When an adapter receives a call, it translates the incoming XML data into a JSON structure and passes the call to the appropriate methods of a wrapped analytics object.",
    "uml_image_url": "https://refactoring.guru/design-patterns/adapter",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// Say you have two classes with compatible interfaces:\n// RoundHole and RoundPeg.\nclass RoundHole is\n    constructor RoundHole(radius) { ... }\n\n    method getRadius() is\n        // Return the radius of the hole.\n\n    method fits(peg: RoundPeg) is\n        return this.getRadius() >= peg.getRadius()\n\nclass RoundPeg is\n    constructor RoundPeg(radius) { ... }\n\n    method getRadius() is\n        // Return the radius of the peg.\n\n\n// But there's an incompatible class: SquarePeg.\nclass SquarePeg is\n    constructor SquarePeg(width) { ... }\n\n    method getWidth() is\n        // Return the square peg width.\n\n\n// An adapter class lets you fit square pegs into round holes.\n// It extends the RoundPeg class to let the adapter objects act\n// as round pegs.\nclass SquarePegAdapter extends RoundPeg is\n    // In reality, the adapter contains an instance of the\n    // SquarePeg class.\n    private field peg: SquarePeg\n\n    constructor SquarePegAdapter(peg: SquarePeg) is\n        this.peg = peg\n\n    method getRadius() is\n        // The adapter pretends that it's a round peg with a\n        // radius that could fit the square peg that the adapter\n        // actually wraps.\n        return peg.getWidth() * Math.sqrt(2) / 2\n\n\n// Somewhere in client code.\nhole = new RoundHole(5)\nrpeg = new RoundPeg(5)\nhole.fits(rpeg) // true\n\nsmall_sqpeg = new SquarePeg(5)\nlarge_sqpeg = new SquarePeg(10)\nhole.fits(small_sqpeg) // this won't compile (incompatible types)\n\nsmall_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)\nlarge_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)\nhole.fits(small_sqpeg_adapter) // true\nhole.fits(large_sqpeg_adapter) // false"
      }
    ],
    "id": "adapter",
    "text_for_embedding": "Pattern Name: Adapter. Problem it solves: Imagine that you’re creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user. At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But there’s a catch: the analytics library only works with data in JSON format. You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the library’s source code in the first place, making this approach impossible. Solution: You can create an . This is a special object that converts the interface of one object so that another object can understand it. An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isn’t even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles. Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Here’s how it works: Sometimes it’s even possible to create a two-way adapter that can convert the calls in both directions. Let’s get back to our stock market app. To solve the dilemma of incompatible formats, you can create XML-to-JSON adapters for every class of the analytics library that your code works with directly. Then you adjust your code to communicate with the library only via these adapters. When an adapter receives a call, it translates the incoming XML data into a JSON structure and passes the call to the appropriate methods of a wrapped analytics object."
  },
  {
    "name": "Singleton",
    "url": "https://refactoring.guru/design-patterns/singleton",
    "problem": "The Singleton pattern solves two problems at the same time, violating the : Nowadays, the Singleton pattern has become so popular that people may call something a even if it solves just one of the listed problems.",
    "solution": "All implementations of the Singleton have these two steps in common: If your code has access to the Singleton class, then it’s able to call the Singleton’s static method. So whenever that method is called, the same object is always returned.",
    "uml_image_url": "https://refactoring.guru/design-patterns/singleton",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The Database class defines the `getInstance` method that lets\n// clients access the same instance of a database connection\n// throughout the program.\nclass Database is\n    // The field for storing the singleton instance should be\n    // declared static.\n    private static field instance: Database\n\n    // The singleton's constructor should always be private to\n    // prevent direct construction calls with the `new`\n    // operator.\n    private constructor Database() is\n        // Some initialization code, such as the actual\n        // connection to a database server.\n        // ...\n\n    // The static method that controls access to the singleton\n    // instance.\n    public static method getInstance() is\n        if (Database.instance == null) then\n            acquireThreadLock() and then\n                // Ensure that the instance hasn't yet been\n                // initialized by another thread while this one\n                // has been waiting for the lock's release.\n                if (Database.instance == null) then\n                    Database.instance = new Database()\n        return Database.instance\n\n    // Finally, any singleton should define some business logic\n    // which can be executed on its instance.\n    public method query(sql) is\n        // For instance, all database queries of an app go\n        // through this method. Therefore, you can place\n        // throttling or caching logic here.\n        // ...\n\nclass Application is\n    method main() is\n        Database foo = Database.getInstance()\n        foo.query(\"SELECT ...\")\n        // ...\n        Database bar = Database.getInstance()\n        bar.query(\"SELECT ...\")\n        // The variable `bar` will contain the same object as\n        // the variable `foo`."
      }
    ],
    "id": "singleton",
    "text_for_embedding": "Pattern Name: Singleton. Problem it solves: The Singleton pattern solves two problems at the same time, violating the : Nowadays, the Singleton pattern has become so popular that people may call something a even if it solves just one of the listed problems. Solution: All implementations of the Singleton have these two steps in common: If your code has access to the Singleton class, then it’s able to call the Singleton’s static method. So whenever that method is called, the same object is always returned."
  },
  {
    "name": "Prototype",
    "url": "https://refactoring.guru/design-patterns/prototype",
    "problem": "Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object. Nice! But there’s a catch. Not all objects can be copied that way because some of the object’s fields may be private and not visible from outside of the object itself. There’s one more problem with the direct approach. Since you have to know the object’s class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn’t scare you, there’s another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface.",
    "solution": "The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single method. The implementation of the method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class. An object that supports cloning is called a . When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing. Here’s how it works: you create a set of objects, configured in various ways. When you need an object like the one you’ve configured, you just clone a prototype instead of constructing a new object from scratch.",
    "uml_image_url": "https://refactoring.guru/design-patterns/prototype",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// Base prototype.\nabstract class Shape is\n    field X: int\n    field Y: int\n    field color: string\n\n    // A regular constructor.\n    constructor Shape() is\n        // ...\n\n    // The prototype constructor. A fresh object is initialized\n    // with values from the existing object.\n    constructor Shape(source: Shape) is\n        this()\n        this.X = source.X\n        this.Y = source.Y\n        this.color = source.color\n\n    // The clone operation returns one of the Shape subclasses.\n    abstract method clone():Shape\n\n\n// Concrete prototype. The cloning method creates a new object\n// in one go by calling the constructor of the current class and\n// passing the current object as the constructor's argument.\n// Performing all the actual copying in the constructor helps to\n// keep the result consistent: the constructor will not return a\n// result until the new object is fully built; thus, no object\n// can have a reference to a partially-built clone.\nclass Rectangle extends Shape is\n    field width: int\n    field height: int\n\n    constructor Rectangle(source: Rectangle) is\n        // A parent constructor call is needed to copy private\n        // fields defined in the parent class.\n        super(source)\n        this.width = source.width\n        this.height = source.height\n\n    method clone():Shape is\n        return new Rectangle(this)\n\n\nclass Circle extends Shape is\n    field radius: int\n\n    constructor Circle(source: Circle) is\n        super(source)\n        this.radius = source.radius\n\n    method clone():Shape is\n        return new Circle(this)\n\n\n// Somewhere in the client code.\nclass Application is\n    field shapes: array of Shape\n\n    constructor Application() is\n        Circle circle = new Circle()\n        circle.X = 10\n        circle.Y = 10\n        circle.radius = 20\n        shapes.add(circle)\n\n        Circle anotherCircle = circle.clone()\n        shapes.add(anotherCircle)\n        // The `anotherCircle` variable contains an exact copy\n        // of the `circle` object.\n\n        Rectangle rectangle = new Rectangle()\n        rectangle.width = 10\n        rectangle.height = 20\n        shapes.add(rectangle)\n\n    method businessLogic() is\n        // Prototype rocks because it lets you produce a copy of\n        // an object without knowing anything about its type.\n        Array shapesCopy = new Array of Shapes.\n\n        // For instance, we don't know the exact elements in the\n        // shapes array. All we know is that they are all\n        // shapes. But thanks to polymorphism, when we call the\n        // `clone` method on a shape the program checks its real\n        // class and runs the appropriate clone method defined\n        // in that class. That's why we get proper clones\n        // instead of a set of simple Shape objects.\n        foreach (s in shapes) do\n            shapesCopy.add(s.clone())\n\n        // The `shapesCopy` array contains exact copies of the\n        // `shape` array's children."
      }
    ],
    "id": "prototype",
    "text_for_embedding": "Pattern Name: Prototype. Problem it solves: Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object. Nice! But there’s a catch. Not all objects can be copied that way because some of the object’s fields may be private and not visible from outside of the object itself. There’s one more problem with the direct approach. Since you have to know the object’s class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn’t scare you, there’s another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface. Solution: The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single method. The implementation of the method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class. An object that supports cloning is called a . When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing. Here’s how it works: you create a set of objects, configured in various ways. When you need an object like the one you’ve configured, you just clone a prototype instead of constructing a new object from scratch."
  },
  {
    "name": "Builder",
    "url": "https://refactoring.guru/design-patterns/builder",
    "problem": "Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code. For example, let’s think about how to create a object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)? The simplest solution is to extend the base class and create a set of subclasses to cover all combinations of the parameters. But eventually you’ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more. There’s another approach that doesn’t involve breeding subclasses. You can create a giant constructor right in the base class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem. In most cases most of the parameters will be unused, making . For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.",
    "solution": "The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called . The pattern organizes object construction into a set of steps ( , ,etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don’t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object. Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone. In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects. For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface. You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called . The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps. Having a director class in your program isn’t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program. In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.",
    "uml_image_url": "https://refactoring.guru/design-patterns/builder",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// Using the Builder pattern makes sense only when your products\n// are quite complex and require extensive configuration. The\n// following two products are related, although they don't have\n// a common interface.\nclass Car is\n    // A car can have a GPS, trip computer and some number of\n    // seats. Different models of cars (sports car, SUV,\n    // cabriolet) might have different features installed or\n    // enabled.\n\nclass Manual is\n    // Each car should have a user manual that corresponds to\n    // the car's configuration and describes all its features.\n\n\n// The builder interface specifies methods for creating the\n// different parts of the product objects.\ninterface Builder is\n    method reset()\n    method setSeats(...)\n    method setEngine(...)\n    method setTripComputer(...)\n    method setGPS(...)\n\n// The concrete builder classes follow the builder interface and\n// provide specific implementations of the building steps. Your\n// program may have several variations of builders, each\n// implemented differently.\nclass CarBuilder implements Builder is\n    private field car:Car\n\n    // A fresh builder instance should contain a blank product\n    // object which it uses in further assembly.\n    constructor CarBuilder() is\n        this.reset()\n\n    // The reset method clears the object being built.\n    method reset() is\n        this.car = new Car()\n\n    // All production steps work with the same product instance.\n    method setSeats(...) is\n        // Set the number of seats in the car.\n\n    method setEngine(...) is\n        // Install a given engine.\n\n    method setTripComputer(...) is\n        // Install a trip computer.\n\n    method setGPS(...) is\n        // Install a global positioning system.\n\n    // Concrete builders are supposed to provide their own\n    // methods for retrieving results. That's because various\n    // types of builders may create entirely different products\n    // that don't all follow the same interface. Therefore such\n    // methods can't be declared in the builder interface (at\n    // least not in a statically-typed programming language).\n    //\n    // Usually, after returning the end result to the client, a\n    // builder instance is expected to be ready to start\n    // producing another product. That's why it's a usual\n    // practice to call the reset method at the end of the\n    // `getProduct` method body. However, this behavior isn't\n    // mandatory, and you can make your builder wait for an\n    // explicit reset call from the client code before disposing\n    // of the previous result.\n    method getProduct():Car is\n        product = this.car\n        this.reset()\n        return product\n\n// Unlike other creational patterns, builder lets you construct\n// products that don't follow the common interface.\nclass CarManualBuilder implements Builder is\n    private field manual:Manual\n\n    constructor CarManualBuilder() is\n        this.reset()\n\n    method reset() is\n        this.manual = new Manual()\n\n    method setSeats(...) is\n        // Document car seat features.\n\n    method setEngine(...) is\n        // Add engine instructions.\n\n    method setTripComputer(...) is\n        // Add trip computer instructions.\n\n    method setGPS(...) is\n        // Add GPS instructions.\n\n    method getProduct():Manual is\n        // Return the manual and reset the builder.\n\n\n// The director is only responsible for executing the building\n// steps in a particular sequence. It's helpful when producing\n// products according to a specific order or configuration.\n// Strictly speaking, the director class is optional, since the\n// client can control builders directly.\nclass Director is\n    // The director works with any builder instance that the\n    // client code passes to it. This way, the client code may\n    // alter the final type of the newly assembled product.\n    // The director can construct several product variations\n    // using the same building steps.\n    method constructSportsCar(builder: Builder) is\n        builder.reset()\n        builder.setSeats(2)\n        builder.setEngine(new SportEngine())\n        builder.setTripComputer(true)\n        builder.setGPS(true)\n\n    method constructSUV(builder: Builder) is\n        // ...\n\n\n// The client code creates a builder object, passes it to the\n// director and then initiates the construction process. The end\n// result is retrieved from the builder object.\nclass Application is\n\n    method makeCar() is\n        director = new Director()\n\n        CarBuilder builder = new CarBuilder()\n        director.constructSportsCar(builder)\n        Car car = builder.getProduct()\n\n        CarManualBuilder builder = new CarManualBuilder()\n        director.constructSportsCar(builder)\n\n        // The final product is often retrieved from a builder\n        // object since the director isn't aware of and not\n        // dependent on concrete builders and products.\n        Manual manual = builder.getProduct()"
      },
      {
        "language": "unknown",
        "code": "class Pizza {\n    Pizza(int size) { ... }\n    Pizza(int size, boolean cheese) { ... }\n    Pizza(int size, boolean cheese, boolean pepperoni) { ... }\n    // ..."
      }
    ],
    "id": "builder",
    "text_for_embedding": "Pattern Name: Builder. Problem it solves: Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code. For example, let’s think about how to create a object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)? The simplest solution is to extend the base class and create a set of subclasses to cover all combinations of the parameters. But eventually you’ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more. There’s another approach that doesn’t involve breeding subclasses. You can create a giant constructor right in the base class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem. In most cases most of the parameters will be unused, making . For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten. Solution: The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called . The pattern organizes object construction into a set of steps ( , ,etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don’t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object. Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone. In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects. For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface. You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called . The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps. Having a director class in your program isn’t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program. In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder."
  },
  {
    "name": "Abstract Factory",
    "url": "https://refactoring.guru/design-patterns/abstract-factory",
    "problem": "Imagine that you’re creating a furniture shop simulator. Your code consists of classes that represent: You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture. Also, you don’t want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn’t want to change the core code each time it happens.",
    "solution": "The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the interface; all coffee table variants can implement the interface, and so on. The next move is to declare the —an interface with a list of creation methods for all products that are part of the product family (for example, , and ). These methods must return product types represented by the interfaces we extracted previously: , , and so on. Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the interface. A factory is a class that returns products of a particular kind. For example, the can only create , and objects. The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code. Say the client wants a factory to produce a chair. The client doesn’t have to be aware of the factory’s class, nor does it matter what kind of chair it gets. Whether it’s a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract interface. With this approach, the only thing that the client knows about the chair is that it implements the method in some way. Also, whichever variant of the chair is returned, it’ll always match the type of sofa or coffee table produced by the same factory object. There’s one more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings.",
    "uml_image_url": "https://refactoring.guru/design-patterns/abstract-factory",
    "code_examples": [
      {
        "language": "unknown",
        "code": "// The abstract factory interface declares a set of methods that\n// return different abstract products. These products are called\n// a family and are related by a high-level theme or concept.\n// Products of one family are usually able to collaborate among\n// themselves. A family of products may have several variants,\n// but the products of one variant are incompatible with the\n// products of another variant.\ninterface GUIFactory is\n    method createButton():Button\n    method createCheckbox():Checkbox\n\n\n// Concrete factories produce a family of products that belong\n// to a single variant. The factory guarantees that the\n// resulting products are compatible. Signatures of the concrete\n// factory's methods return an abstract product, while inside\n// the method a concrete product is instantiated.\nclass WinFactory implements GUIFactory is\n    method createButton():Button is\n        return new WinButton()\n    method createCheckbox():Checkbox is\n        return new WinCheckbox()\n\n// Each concrete factory has a corresponding product variant.\nclass MacFactory implements GUIFactory is\n    method createButton():Button is\n        return new MacButton()\n    method createCheckbox():Checkbox is\n        return new MacCheckbox()\n\n\n// Each distinct product of a product family should have a base\n// interface. All variants of the product must implement this\n// interface.\ninterface Button is\n    method paint()\n\n// Concrete products are created by corresponding concrete\n// factories.\nclass WinButton implements Button is\n    method paint() is\n        // Render a button in Windows style.\n\nclass MacButton implements Button is\n    method paint() is\n        // Render a button in macOS style.\n\n// Here's the base interface of another product. All products\n// can interact with each other, but proper interaction is\n// possible only between products of the same concrete variant.\ninterface Checkbox is\n    method paint()\n\nclass WinCheckbox implements Checkbox is\n    method paint() is\n        // Render a checkbox in Windows style.\n\nclass MacCheckbox implements Checkbox is\n    method paint() is\n        // Render a checkbox in macOS style.\n\n\n// The client code works with factories and products only\n// through abstract types: GUIFactory, Button and Checkbox. This\n// lets you pass any factory or product subclass to the client\n// code without breaking it.\nclass Application is\n    private field factory: GUIFactory\n    private field button: Button\n    constructor Application(factory: GUIFactory) is\n        this.factory = factory\n    method createUI() is\n        this.button = factory.createButton()\n    method paint() is\n        button.paint()\n\n\n// The application picks the factory type depending on the\n// current configuration or environment settings and creates it\n// at runtime (usually at the initialization stage).\nclass ApplicationConfigurator is\n    method main() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == \"Windows\") then\n            factory = new WinFactory()\n        else if (config.OS == \"Mac\") then\n            factory = new MacFactory()\n        else\n            throw new Exception(\"Error! Unknown operating system.\")\n\n        Application app = new Application(factory)"
      }
    ],
    "id": "abstract-factory",
    "text_for_embedding": "Pattern Name: Abstract Factory. Problem it solves: Imagine that you’re creating a furniture shop simulator. Your code consists of classes that represent: You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture. Also, you don’t want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn’t want to change the core code each time it happens. Solution: The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the interface; all coffee table variants can implement the interface, and so on. The next move is to declare the —an interface with a list of creation methods for all products that are part of the product family (for example, , and ). These methods must return product types represented by the interfaces we extracted previously: , , and so on. Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the interface. A factory is a class that returns products of a particular kind. For example, the can only create , and objects. The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code. Say the client wants a factory to produce a chair. The client doesn’t have to be aware of the factory’s class, nor does it matter what kind of chair it gets. Whether it’s a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract interface. With this approach, the only thing that the client knows about the chair is that it implements the method in some way. Also, whichever variant of the chair is returned, it’ll always match the type of sofa or coffee table produced by the same factory object. There’s one more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings."
  }
]